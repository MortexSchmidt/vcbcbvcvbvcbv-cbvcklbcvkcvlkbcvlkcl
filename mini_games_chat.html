<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0b0f14;
            --card: #0f1720;
            --muted: #98a0b3;
            --text: #e6eef8;
            --accent: #6c8cff;
            --success: #22c55e;
            --danger: #ff6b6b;
            --glass: rgba(255,255,255,0.03);
            --shadow-1: 0 8px 28px rgba(2,6,23,0.6);
            --radius: 12px;
            --radius-sm: 8px;
            --gap: 14px;
            --transition: 180ms cubic-bezier(.2,.9,.2,1);
        }

        * { box-sizing: border-box; }
        html, body { height: 100%; }
    /* allow children to shrink properly inside flex/grid */
    .app-container, .app-main, .game-selection, .game-card, .view { min-width: 0 }

    /* ensure long text wraps instead of overflowing */
    .game-card, .menu-btn, .game-card button, .menu-btn, input, .bottom-nav button { word-break: break-word; white-space: normal }

    /* responsive tic-tac-toe board */
    #board { grid-template-columns: repeat(3, minmax(0, 1fr)); gap:8px; width:100%; max-width:520px }
    .ttt-cell { aspect-ratio: 1 / 1; width:100%; min-width:0; padding:0; }
        /* Disable default blue tap highlight and browser focus outlines on mobile */
        html, body, button, a, input, textarea, select {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }

        /* Remove outlines and default focus rings for interactive controls */
        button, .menu-btn, .game-card button, .ttt-cell, .game-choose, .game-lobby {
            outline: none !important;
            -webkit-appearance: none;
            appearance: none;
        }

        :focus { outline: none !important; box-shadow: none !important; }
        body {
            margin: 0;
            font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom);
            -webkit-font-smoothing: antialiased;
        }

        /* Disable text selection globally; allow only specific interactive elements */
        * {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
        }
        /* Allow selection in inputs, textareas, contenteditable and elements explicitly marked .allow-select or the auth modal */
        input, textarea, [contenteditable="true"], .allow-select, #auth-modal, #auth-modal * {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }

        .app-container {
            width: 100%;
            max-width: 980px;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: var(--shadow-1);
            background: var(--card);
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 22px;
            height: calc(100vh - 28px);
        }

        /* Sidebar */
        .app-sidebar {
            padding: 18px;
            background: transparent;
            border-right: 1px solid rgba(255,255,255,0.03);
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: 100%;
        }

        .profile-row { display:flex; align-items:center; gap:12px; }
        .avatar { width:56px; height:56px; border-radius:12px; overflow:hidden; background:var(--glass); display:flex; align-items:center; justify-content:center; }
        .avatar img{ width:100%; height:100%; object-fit:cover }
        .profile-info { display:flex; flex-direction:column }
        .profile-name { font-weight:600 }
        .profile-sub { font-size:0.9rem; color:var(--muted) }

        .menu-buttons { display:flex; flex-direction:column; gap:10px; margin-top:6px }
        .menu-btn { display:flex; align-items:center; gap:12px; padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); background:transparent; color:var(--text); cursor:pointer; transition:all var(--transition); font-weight:600; text-align:left; min-height:48px }
        .menu-btn.primary { background:var(--accent); color:#07102a; border:0 }
        .menu-btn.disabled { background:var(--muted); color:var(--card); cursor:not-allowed }
        .menu-btn:hover:not(.disabled){ transform:translateY(-1px); box-shadow:0 6px 18px rgba(2,6,23,0.55) }

        .app-main { padding:22px; display:flex; flex-direction:column; gap:18px; background:transparent; height:100%; overflow:auto }

        /* Game selection — on desktop column, on mobile horizontal cards */
    .game-selection { display:flex; flex-direction:column; gap:12px }
        .game-card { background:var(--card); border:1px solid var(--glass); border-radius:var(--radius); padding:16px; display:flex; flex-direction:column; gap:8px; }
        .game-card h3 { font-weight:600; color:var(--text); margin:0 }
        .game-card button { padding:12px 16px; border-radius:var(--radius-sm); border:1px solid var(--glass); background:var(--accent); color:#07102a; font-weight:700; cursor:pointer; transition:all var(--transition); }
        .game-card button.disabled { background:var(--muted); color:var(--card); cursor:not-allowed }
        .game-card button:hover:not(.disabled){ transform:translateY(-2px); box-shadow:0 8px 20px rgba(2,6,23,0.55) }

    /* Lobby list styles */
    .lobbies-list { display:flex; flex-direction:column; gap:10px }
    .lobby-card { display:flex; align-items:center; gap:12px; padding:12px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border:1px solid rgba(255,255,255,0.03); transition:transform .12s ease, box-shadow .12s ease }
    .lobby-card:hover { transform:translateY(-4px); box-shadow:0 10px 30px rgba(2,6,23,0.5) }
    .lobby-avatar { width:44px; height:44px; border-radius:10px; background:var(--glass); display:flex; align-items:center; justify-content:center; font-weight:700; color:var(--text) }
    /* prevent avatar images from overflowing their container and keep consistent sizing */
    .lobby-avatar { overflow: hidden; flex: 0 0 44px; }
    .lobby-avatar img { width: 100%; height: 100%; object-fit: cover; display: block; border-radius: 8px; }
    .lobby-info { flex:1; min-width:0 }
    .lobby-name { font-weight:700; font-size:15px; color:var(--text); margin-bottom:4px }
    .lobby-meta { color:var(--muted); font-size:13px }
    .lobby-actions { display:flex; gap:8px }
    .lobby-actions { align-items: center; }
    .badge { padding:6px 8px; border-radius:999px; font-size:12px; font-weight:700; color:#07102a; background:var(--accent); }
    .badge.wait { background:#ffd166; color:#07102a }
    .badge.playing { background:var(--success); color:#07102a }

        /* Bottom navigation for mobile */
        .bottom-nav { display:none }

        /* Responsive adjustments for small screens (phones) */
        @media (max-width: 720px) {
            .app-container { grid-template-columns: 1fr; max-width:100%; border-radius:0; height:100vh }
            .app-sidebar { display:none }
            .app-main { padding:18px 14px 92px 14px }

            /* show cards as one column on phones (vertical layout) */
            .game-selection { display:grid; grid-template-columns: 1fr; gap:12px; padding-bottom:12px }
            .game-card { width:100%; box-shadow: 0 6px 18px rgba(2,6,23,0.45); }

            /* bottom nav */
            .bottom-nav { position:fixed; left:0; right:0; bottom:0; height:74px; display:flex; gap:4px; align-items:center; justify-content:space-around; padding:8px calc(12px + env(safe-area-inset-left)) calc(8px + env(safe-area-inset-bottom)); background:linear-gradient(180deg, rgba(15,20,32,0.85), rgba(8,10,14,0.95)); border-top:1px solid rgba(255,255,255,0.04); backdrop-filter: blur(8px); z-index:50 }
            .bottom-nav button { background:transparent; border:none; color:var(--text); display:flex; flex-direction:column; align-items:center; gap:6px; font-weight:600; font-size:12px; padding:6px 8px; cursor:pointer }
            .bottom-nav svg { width:22px; height:22px; opacity:0.95 }

            /* Lobby header: stack input + button on very small screens */
            #view-lobby > div { justify-content: flex-start !important; align-items: flex-start; flex-direction: column; gap:8px; }
            /* place input and button on the same row, left aligned */
            #view-lobby > div > div { display:flex; flex-direction:row; gap:8px; align-items:center; }
            #lobby-name { flex: 1 1 auto; min-width:0; width: auto; margin:0; }
            #btn-create-lobby { flex: 0 0 auto; }

            /* Lobbies list layout improvements */
            .lobbies-list { padding: 6px 0; display:flex; flex-direction:column; gap:10px; }
            .lobby-card { width:100%; display:flex; flex-direction:row; align-items:center; gap:12px; padding:12px; border-radius:12px; box-shadow: 0 6px 18px rgba(2,6,23,0.25); background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent); }
            .lobby-avatar { width:44px; height:44px; flex:0 0 44px; border-radius:10px; }
            .lobby-info { flex:1 1 auto; min-width:0; }
            .lobby-actions { display:flex; gap:8px; flex:0 0 auto; }
            .lobby-name { font-size:15px; }
        }
        /* desktop keeps default column layout for game selection (restore original) */

        /* Game card selection styles + floating Play button */
        .game-card { transition: box-shadow var(--transition), outline var(--transition); }
        .game-card:focus { outline: 2px dashed rgba(108,140,255,0.18); }
    /* make selection visually robust even when global focus outlines are suppressed */
    .game-card.selected { border: 2px solid var(--accent); box-shadow: 0 14px 40px rgba(108,140,255,0.28); background: linear-gradient(180deg, rgba(20,30,60,0.6), rgba(12,20,34,0.6)); transform: translateY(-4px); animation: glow 900ms ease-in-out infinite alternate; }
        @keyframes glow { from { box-shadow: 0 8px 24px rgba(108,140,255,0.12); } to { box-shadow: 0 18px 44px rgba(108,140,255,0.28); } }

        .play-button {
            position: fixed;
            left: 50%;
            bottom: 86px; /* sits above bottom-nav */
            transform: translateX(-50%) translateY(0) scale(.98);
            background: var(--accent);
            color: #07102a;
            padding: 12px 28px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 700;
            box-shadow: var(--shadow-1);
            opacity: 0;
            transition: opacity 260ms cubic-bezier(.2,.9,.2,1), transform 260ms cubic-bezier(.2,.9,.2,1);
            z-index: 1001;
            border: none;
            pointer-events: none;
        }
        /* Ensure search indicator can render expanded content above the pill without shifting the pill itself */
        #search-indicator { overflow: visible; }
        #search-indicator .search-bar { position: relative; z-index: 2; }
        #search-indicator .search-expanded {
            position: absolute;
            left: 0;
            right: 0;
            bottom: calc(100% + 10px); /* place above the pill */
            background: transparent;
            transform: translateY(8px);
            opacity: 0;
            pointer-events: none;
            transition: transform 240ms cubic-bezier(.2,.9,.2,1), opacity 200ms ease;
            z-index: 1;
            display: block; /* kept in flow but hidden via opacity/transform */
        }
        #search-indicator .search-expanded.expanded {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

            /* Long-search animations: title slides up, alt title slides in from below, pill turns yellow */
            .search-bar { transition: background-color 600ms cubic-bezier(.2,.9,.2,1), color 600ms; }
            .search-bar .title-wrap { position:relative; display:inline-block; width:auto; height:20px; overflow:hidden; vertical-align:middle; }
            #search-title, #search-alt-title { display:block; position:relative; width:100%; left:0; right:0; }
            /* hidden by default: alt title sits below */
            #search-alt-title { transform: translateY(100%); opacity: 0; }

            @keyframes slideUpFade {
                from { transform: translateY(0%); opacity: 1 }
                to   { transform: translateY(-100%); opacity: 0 }
            }
            @keyframes slideInFromBelow {
                from { transform: translateY(100%); opacity: 0 }
                to   { transform: translateY(0%); opacity: 1 }
            }

            .search-bar.long-search #search-title { opacity: 0; transform: translateY(-100%); }
            .search-bar.long-search #search-alt-title { opacity: 1; transform: translateY(0%); }
            .search-bar.long-search { background: linear-gradient(90deg,#ffd166,#ffd166); color: #07102a !important; }

            /* Play button / card button highlight for long search */
            .menu-btn.long-search { transition: background-color 600ms; background: #ffd166 !important; color: #07102a !important; border-color: rgba(0,0,0,0.06) !important; }

        #search-long-text { transition: transform 420ms cubic-bezier(.2,.9,.2,1), opacity 420ms; transform: translateY(6px); opacity: 0; }
        /* Desktop anchored variant: compact card inside sidebar area. Keep limited height so it doesn't cover content. */
        #search-indicator[data-desktop="1"] {
            border-radius: 12px; box-shadow: 0 12px 40px rgba(2,6,23,0.6); background: linear-gradient(90deg,#0f1720, #0b1220); padding: 6px; z-index: 60; overflow: visible;
        }
        #search-indicator[data-desktop="1"] .search-bar { border-radius: 10px; padding: 8px 12px; font-weight:700; display:flex; align-items:center }
        #search-indicator[data-desktop="1"] .search-expanded { position: relative; bottom: auto; transform: none; opacity: 1; pointer-events: auto; margin-top:8px; max-height: 140px; overflow: auto; }
        #search-indicator[data-desktop="1"] #search-player-row { justify-content: flex-start; }
        /* Desktop: restore visible styles — colored pill on top and card-like details below */
        #search-indicator[data-desktop="1"] {
            border-radius: 12px;
            box-shadow: 0 12px 40px rgba(2,6,23,0.6);
            background: linear-gradient(180deg, rgba(11,15,22,0.6), rgba(10,14,20,0.85));
            padding: 6px;
            z-index: 60;
        }
        #search-indicator[data-desktop="1"] .search-bar { 
            border-radius: 10px; padding: 8px 12px; font-weight:700; display:flex; align-items:center;
            background: linear-gradient(90deg,#6b8cff,#5a6bd8); color: #07102a; box-shadow: none; 
        }
        #search-indicator[data-desktop="1"] .search-expanded { 
            position: relative; bottom: auto; transform: none; opacity: 1; pointer-events: auto; margin-top:8px;
            background: var(--card); border: 1px solid var(--glass); border-radius:10px; padding:8px; max-height:140px; overflow:auto; 
        }
    /* End-game modal styles */
    .end-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(2,6,23,0.8); z-index: 1300 }
    .end-card { width: 92%; max-width: 520px; background: linear-gradient(180deg, rgba(20,30,60,0.9), rgba(10,14,26,0.95)); border-radius: 16px; padding: 20px; border: 1px solid rgba(255,255,255,0.04); box-shadow: 0 18px 60px rgba(2,6,23,0.8); transform: translateY(12px) scale(.98); opacity: 0; animation: popIn 420ms cubic-bezier(.2,.9,.2,1) forwards; display:flex; flex-direction:column; align-items:center; gap:12px }
    @keyframes popIn { to { transform: translateY(0) scale(1); opacity: 1 } }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .winner-emoji { font-size:48px }
    .winner-avatar { width:84px; height:84px; border-radius:20px; overflow:hidden; background:var(--glass); display:flex; align-items:center; justify-content:center; }
    /* mini board in end modal */
    .end-mini { display:grid; grid-template-columns: repeat(3, 18px); grid-template-rows: repeat(3, 18px); gap:6px; margin-top:6px }
    .end-mini .mini-cell { width:18px; height:18px; border-radius:6px; background:transparent; display:flex; align-items:center; justify-content:center; border:1px solid rgba(255,255,255,0.04) }
    .end-mini .mini-cell .icon-x svg line { stroke-width:2 }
    .end-mini .mini-cell .icon-o svg circle { stroke-width:2 }
    .winner-name { font-size:20px; font-weight:800; color:var(--text) }
    .winner-sub { color:var(--muted); font-size:14px }
    .end-actions { display:flex; gap:10px; margin-top:6px }
    /* board icons */
    .icon-x svg, .icon-o svg { width:100%; height:100%; display:block }
    /* reduced stroke widths so icons fit better in small cells */
    .icon-x svg line { stroke: #ffffff; stroke-width:3; stroke-linecap:round }
    .icon-o svg circle { stroke: #ffffff; stroke-width:3; fill: none }
        .play-button.visible { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); pointer-events: auto; }

          /* Confirm modal responsive fixes: allow players area to wrap on small widths
              and prevent name overflow with ellipsis. */
          #confirm-box #confirm-players { flex-wrap: wrap; }
          #confirm-box #confirm-player-a, #confirm-box #confirm-player-b { min-width: 0; flex: 1 1 180px; justify-content: flex-start; }
          #confirm-box .confirm-avatar { flex: 0 0 52px; width:52px; height:52px; }
          #confirm-box #confirm-player-a > div, #confirm-box #confirm-player-b > div { min-width: 0; overflow: hidden; }
          #confirm-box #confirm-name-a, #confirm-box #confirm-name-b { display: block; max-width: calc(100% - 64px); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
          #confirm-box #confirm-meta-a, #confirm-box #confirm-meta-b { display:block; }

        @media (max-width: 720px) {
            /* Mobile layout: one card per row, show per-card Play buttons */
            .game-selection { flex-direction: column; }
            .game-card { width: 100%; min-width: 0; }
            .game-card .game-choose, .game-card .game-lobby, .game-card button { display: block !important; }
                    /* do not auto-show per-card play buttons on mobile; they appear after selection */
                    /* hide card-play-btn by default (increase specificity so generic .game-card button rule doesn't override)
                        show only when the card is selected or the button is in searching state */
                    .game-card button.card-play-btn { width: 100%; box-sizing: border-box; display: none !important; }
                    .game-card.selected button.card-play-btn { display: block !important; }
                    .game-card button.card-play-btn[data-searching="1"] { display: block !important; }
            /* place search indicator above bottom-nav and stretch across the menu area */
            #search-indicator { left: 0 !important; right: 0 !important; bottom: 84px !important; transform: none !important; min-width: unset !important; width: calc(100% - 28px) !important; margin: 0 14px; }
            /* align title left and timer right inside the pill; avatar/name row left-aligned */
            #search-indicator .search-bar { justify-content: space-between; width: 100%; border-radius: 12px; }
            .game-card { cursor: pointer; }
        }
        /* Ensure per-card play buttons are always clickable and above overlays */
        /* keep play buttons clickable but below modals (modals have z-index >= 1200) */
        .card-play-btn { pointer-events: auto !important; position: relative !important; z-index: 90 !important; }
    </style>
</head>
<body>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <!-- pako: zlib inflate for .tgs (zlib-compressed lottie json), lottie-web to render animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.10.1/lottie.min.js"></script>

    <div class="app-container">
        <aside class="app-sidebar">
            <div class="profile-row">
                <div class="avatar">
                    <img src="" alt="avatar" onerror="this.src='https://ui-avatars.com/api/?name=Guest&background=5865f2&color=ffffff&size=128';">
                </div>
                <div class="profile-info">
                    <div class="profile-name">Гость</div>
                    <div class="profile-sub">Не авторизован</div>
                </div>
            </div>

            <div class="menu-buttons">
                <button class="menu-btn primary" data-action="go-home">Играть</button>
                <button class="menu-btn" data-action="go-lobby">Лобби</button>
                <button class="menu-btn" data-action="go-settings">Настройки</button>
            </div>
        </aside>

        <main class="app-main">
            <!-- Views: home, lobby, game, settings -->
            <section id="view-home" class="view" data-view="home">
                <h2 style="margin:0 0 6px 0">Мини‑игры</h2>
                <p style="margin:0 0 12px 0;color:var(--muted)">Выберите игру и запустите. На телефоне — свайпните карточки.</p>

                <div class="game-selection" role="list">
                    <article class="game-card" data-game="tictactoe" role="listitem">
                        <h3>Крестики‑Нолики</h3>
                        <p style="margin:0;color:var(--muted);font-size:13px">Быстрая игра 1 на 1 в реальном времени.</p>
                        <div style="height:6px"></div>
                        <!-- Кнопка 'Играть' будет добавлена динамически при выборе игры -->
                    </article>

                    <article class="game-card" data-game="memory" aria-disabled="true">
                        <h3>Мемо (скоро)</h3>
                        <p style="margin:0;color:var(--muted);font-size:13px">Карточная память — в разработке.</p>
                        <div style="height:6px"></div>
                        <!-- кнопки 'Играть' для этой карточки удалены: игра не готова -->
                    </article>

                    <article class="game-card" data-game="quiz" aria-disabled="true">
                        <h3>Quiz (скоро)</h3>
                        <p style="margin:0;color:var(--muted);font-size:13px">Викторина против друзей.</p>
                        <div style="height:6px"></div>
                        <!-- кнопки 'Играть' для этой карточки удалены: игра не готова -->
                    </article>
                </div>
            </section>

            <section id="view-lobby" class="view" data-view="lobby" style="display:none">
                <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
                    <h2 style="margin:0">Лобби</h2>
                        <div style="display:flex;gap:8px;align-items:center;justify-content:center">
                            <button id="btn-create-lobby" class="menu-btn primary">Создать</button>
                        </div>
                </div>

                    <div id="lobbies-list" class="lobbies-list" style="margin-top:12px"></div>
            </section>

            <section id="view-game" class="view" data-view="game" style="display:none">
                <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
                    <h2 style="margin:0" id="game-title">Крестики‑Нолики</h2>
                    <div id="game-status" style="color:var(--muted);font-size:13px">Ожидание игрока...</div>
                </div>

                <div id="players-row" style="display:flex;gap:12px;align-items:center;margin-top:8px"></div>

                <div id="board" style="margin-top:16px;display:grid;grid-template-columns:repeat(3,1fr);gap:8px;max-width:360px">
                    <!-- cells injected here -->
                </div>

                <div style="margin-top:12px;display:flex;gap:8px">
                    <button id="btn-leave" class="menu-btn">Выйти из игры</button>
                    <button id="btn-forfeit" class="menu-btn">Сдаться</button>
                </div>
            </section>

            <section id="view-settings" class="view" data-view="settings" style="display:none">
                <h2 style="margin:0 0 10px 0">Настройки</h2>
                <p style="color:var(--muted)">Здесь будут настройки звука и уведомлений.</p>
            </section>
        </main>
    </div>

    <!-- Auth modal (blocks UI until authorized) -->
    <div id="auth-modal" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(2,6,23,0.6);z-index:200">
        <div style="width:92%;max-width:420px;background:var(--card);border-radius:12px;padding:18px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 12px 40px rgba(2,6,23,0.6)">
            <h3 style="margin:0 0 8px 0">Авторизация</h3>
            <p style="margin:0 0 12px 0;color:var(--muted)">Чтобы играть в мини‑игры и использовать профиль Telegram, авторизуйтесь через бота. Это быстро и безопасно.</p>
            <div id="auth-state" style="margin-bottom:12px;color:var(--muted)">Нажмите «Получить код» и отправьте его боту командой <code>/start auth:&lt;код&gt;</code>.</div>
            <div style="display:flex;gap:8px;align-items:center">
                <button id="btn-get-code" class="menu-btn">Получить код</button>
                <input id="auth-code" readonly style="flex:1;padding:8px;border-radius:10px;border:1px solid var(--glass);background:transparent;color:var(--text);min-width:0">
                <button id="btn-copy-code" class="menu-btn">Копировать</button>
            </div>
            <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
                <button id="btn-auth-close" class="menu-btn" style="display:none">Закрыть</button>
            </div>
        </div>
    </div>

    <!-- Inline quick-match status (compact, expandable) -->
    <div id="search-indicator" class="search-indicator" style="position:fixed;left:50%;bottom:140px;transform:translateX(-50%);display:none;z-index:1002;min-width:180px">
        <div class="search-bar" role="button" aria-expanded="false" tabindex="0" style="display:flex;align-items:center;gap:8px;padding:8px 12px;border-radius:10px;background:linear-gradient(90deg, #6b8cff, #5a6bd8);border:1px solid rgba(255,255,255,0.03);font-weight:700;color:#07102a;text-align:center;cursor:pointer">
            <div class="title-wrap"><div id="search-title" style="font-weight:800;color:#07102a">Поиск</div><div id="search-alt-title" style="font-weight:800;color:#07102a">Долгий поиск</div></div>
            <div id="search-timer-compact" style="margin-left:auto;font-weight:700;color:#07102a">00:00</div>
            <div id="search-arrow" style="margin-left:6px;transition:transform .18s ease;color:#07102a">▾</div>
        </div>
            <div class="search-expanded" style="max-height:0;overflow:hidden;transition:max-height .22s ease,opacity .18s ease;opacity:0;padding:0 12px">
            <div id="search-timer-text" style="margin-top:8px;font-weight:700">Поиск: 00:00</div>
            <div id="search-game-text" style="color:var(--muted);font-weight:600;margin-top:6px;font-size:13px">Игра: —</div>
            <div id="search-player-row" style="display:flex;align-items:center;gap:8px;justify-content:flex-start;margin-top:6px;">
                <div style="color:var(--muted);font-weight:600;font-size:13px">Игрок:</div>
                <div id="search-player-avatar" style="width:32px;height:32px;border-radius:8px;overflow:hidden;background:var(--glass);display:flex;align-items:center;justify-content:center;font-weight:700;color:var(--text);font-size:12px"></div>
                <div id="search-player-name" style="color:var(--muted);font-weight:600;font-size:13px">—</div>
            </div>
            <div id="search-found-text" style="color:var(--muted);font-weight:600;margin-top:6px;font-size:12px">Игроков найдено: 0</div>
            <div id="search-long-text" style="display:none;color:var(--muted);font-weight:600;margin-top:6px;font-size:12px">Долгий поиск</div>
            <div style="display:flex;justify-content:center;margin-top:8px;padding-bottom:8px">&nbsp;</div>
        </div>
    </div>

    <!-- Blocking match confirmation modal (appears when match found) -->
    <div id="confirm-modal" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(2,6,23,0.85);z-index:1201;pointer-events:auto">
        <div style="position:absolute;inset:0;background:transparent;z-index:1201"></div>
        <div id="confirm-box" style="width:92%;max-width:520px;background:var(--card);border-radius:12px;padding:18px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 12px 40px rgba(2,6,23,0.6);z-index:1202;pointer-events:auto">
            <h3 id="confirm-title" style="margin:0 0 8px 0">Матч найден</h3>
            <p id="confirm-desc" style="margin:0 0 12px 0;color:var(--muted)">Подтвердите участие. Выйдя — вы получите временный бан.</p>
            <div id="confirm-players" style="display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px">
                <div id="confirm-player-a" style="display:flex;align-items:center;gap:8px;flex:1;justify-content:center">
                    <div class="confirm-avatar" id="confirm-avatar-a" style="width:52px;height:52px;border-radius:10px;background:var(--glass);display:flex;align-items:center;justify-content:center;overflow:hidden;font-weight:700;color:var(--text)">—</div>
                    <div style="text-align:left;min-width:0"><div id="confirm-name-a" style="font-weight:700">—</div><div id="confirm-meta-a" style="color:var(--muted);font-size:12px">Вы</div></div>
                </div>
                <div style="flex:0 0 8px;text-align:center;color:var(--muted);font-weight:700">VS</div>
                <div id="confirm-player-b" style="display:flex;align-items:center;gap:8px;flex:1;justify-content:center">
                    <div class="confirm-avatar" id="confirm-avatar-b" style="width:52px;height:52px;border-radius:10px;background:var(--glass);display:flex;align-items:center;justify-content:center;overflow:hidden;font-weight:700;color:var(--text)">—</div>
                    <div style="text-align:left;min-width:0"><div id="confirm-name-b" style="font-weight:700">—</div><div id="confirm-meta-b" style="color:var(--muted);font-size:12px">Ожидание</div></div>
                </div>
            </div>
            <div id="confirm-actions-row" style="display:flex;gap:8px;justify-content:space-between;align-items:center">
                <div id="confirm-timer" style="font-weight:700;color:var(--accent)">15</div>
                <div id="confirm-buttons" style="display:flex;gap:8px;justify-content:flex-end">
                    <button id="btn-accept" class="menu-btn primary">Подтвердить</button>
                </div>
            </div>
            <div id="confirm-waiting" style="display:none;margin-top:12px;color:var(--muted);font-weight:700">Ждём подтверждения других игроков...</div>
        </div>
    </div>

    <!-- Reload confirmation modal (appears when user attempts to refresh during a game) -->
    <div id="reload-confirm-modal" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(2,6,23,0.7);z-index:1250">
        <div style="width:92%;max-width:420px;background:var(--card);border-radius:12px;padding:18px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 12px 40px rgba(2,6,23,0.6)">
            <h3 style="margin:0 0 8px 0">Перезагрузить страницу?</h3>
            <p style="margin:0 0 12px 0;color:var(--muted)">Если вы перезагрузите страницу, игра будет завершена. Вы уверены?</p>
            <div style="display:flex;gap:8px;justify-content:flex-end">
                <button id="reload-cancel" class="menu-btn">Отмена</button>
                <button id="reload-confirm" class="menu-btn primary">Перезагрузить и закончить игру</button>
            </div>
        </div>
    </div>

    <!-- Custom loading modal shown before game starts -->
    <!-- Preload modal: full-screen solid dark-blue background -->
    <div id="preload-modal" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#07102a;z-index:1300;pointer-events:auto;color:var(--text)">
        <div style="position:absolute;inset:0;background:#07102a;z-index:1300"></div>
    <!-- fullscreen box: covers entire viewport with centered animation -->
        <div id="preload-box" style="width:100%;max-width:none;height:100%;background:transparent;border-radius:0;padding:0;border:0;box-shadow:none;z-index:1301;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:auto">
            <!-- Center animation (user will upload loading.tgs to this path) - animation constrained to 480px -->
            <div id="preload-center" style="width:100%;height:100%;display:flex;align-items:center;justify-content:center">
                <div style="width:480px;max-width:90%;height:auto;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px">
                    <!-- Container where .tgs will be decoded and played via lottie-web -->
                    <div id="preload-lottie" style="width:100%;height:480px;display:flex;align-items:center;justify-content:center;"> </div>
                    <!-- Image fallback (if someone uploaded a gif/png instead) -->
                    <img id="preload-tgs" src="/assets/loading.tgs" alt="loading animation" style="width:100%;height:auto;object-fit:contain;display:none" onerror="this.style.display='none'">
                    <!-- Fallback simple SVG animation if .tgs cannot be decoded -->
                    <div id="preload-fallback-wrap" style="display:none;flex-direction:column;align-items:center;gap:8px">
                        <svg id="preload-fallback" viewBox="0 0 100 100" width="120" height="120" style="display:block">
                        <circle cx="50" cy="50" r="40" stroke="rgba(108,140,255,0.9)" stroke-width="6" fill="none" stroke-linecap="round">
                            <animateTransform attributeName="transform" type="rotate" from="0 50 50" to="360 50 50" dur="1s" repeatCount="indefinite" />
                        </circle>
                        </svg>
                        <div id="preload-fallback-text" style="color:var(--muted);font-weight:700">Анимация недоступна</div>
                    </div>
                </div>
            </div>
            <div style="display:flex;flex-direction:column;align-items:center;gap:6px;margin-top:18px">
                    <div style="color:var(--text);font-weight:800;font-size:20px;text-align:center">Загрузка</div>
                <div style="margin-top:6px;text-align:center;color:var(--muted);font-weight:700">Пожалуйста, подождите</div>
            </div>
        </div>
        <!-- bottom-right spinner: positioned absolutely inside modal -->
        <div id="preload-bottom-spinner" style="position:absolute;right:28px;bottom:28px;width:44px;height:44px;border-radius:22px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;z-index:1310">
            <div style="width:28px;height:28px;border:3px solid rgba(108,140,255,0.14);border-top-color:var(--accent);border-radius:50%;animation:spin 800ms linear infinite"></div>
        </div>
    </div>

    <!-- Bottom nav для телефонов -->
    <nav class="bottom-nav" aria-hidden="false">
        <button class="bottom-play" data-action="go-home" title="Играть">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 3v18l15-9L5 3z" fill="currentColor"/></svg>
            <span>Играть</span>
        </button>
        <button class="bottom-lobby" data-action="go-lobby" title="Лобби">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 12c2.761 0 5-2.239 5-5s-2.239-5-5-5-5 2.239-5 5 2.239 5 5 5zm0 2c-3.86 0-7 3.14-7 7h2c0-2.761 2.239-5 5-5s5 2.239 5 5h2c0-3.86-3.14-7-7-7z" fill="currentColor"/></svg>
            <span>Лобби</span>
        </button>
        <button class="bottom-settings" data-action="go-settings" title="Настройки">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19.14 12.936a7.072 7.072 0 0 0 0-1.872l2.03-1.58a.5.5 0 0 0 .12-.64l-1.92-3.32a.5.5 0 0 0-.6-.22l-2.39.96a6.987 6.987 0 0 0-1.62-.94l-.36-2.54A.5.5 0 0 0 14.5 2h-4a.5.5 0 0 0-.5.42l-.36 2.54c-.57.22-1.11.52-1.62.94l-2.39-.96a.5.5 0 0 0-.6.22L2.71 8.87a.5.5 0 0 0 .12.64l2.03 1.58c-.05.31-.08.63-.08.95s.03.64.08.95L2.83 14.5a.5.5 0 0 0-.12.64l1.92 3.32c.14.24.44.34.69.22l2.39-.96c.5.42 1.05.72 1.62.94l.36 2.54c.05.28.28.48.56.48h4c.28 0 .51-.2.56-.48l.36-2.54c.57-.22 1.11-.52 1.62-.94l2.39.96c.25.1.55.02.69-.22l1.92-3.32a.5.5 0 0 0-.12-.64l-2.03-1.58zM12 15.5A3.5 3.5 0 1 1 12 8.5a3.5 3.5 0 0 1 0 7z" fill="currentColor"/></svg>
            <span>Настройки</span>
        </button>
    </nav>

    <!-- End game modal -->
    <div id="end-modal" class="end-modal">
        <div class="end-card" id="end-card">
            <div class="winner-avatar" id="winner-avatar"></div>
            <div class="winner-emoji" id="winner-emoji">
                <!-- Animated Telegram .tgs sticker will render here. If loading fails, the SVG fallback below will remain hidden and can be shown instead. -->
                <div id="tgs-trophy" style="width:48px;height:48px;display:flex;align-items:center;justify-content:center"></div>
                <!-- fallback SVG (kept for browsers where animation cannot load) -->
                <svg id="svg-trophy" style="display:none" viewBox="0 0 24 24" width="48" height="48" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M7 3h10v2a4 4 0 0 1-4 4h-2A4 4 0 0 1 7 5V3z" fill="#ffffff"/><path d="M5 7v2a5 5 0 0 0 5 5h4a5 5 0 0 0 5-5V7" stroke="#ffffff" stroke-width="0" fill="#ffffff"/><path d="M10 19h4v2h-4z" fill="#ffffff"/></svg>
            </div>
            <div class="winner-name" id="winner-name">Победитель</div>
            <div class="winner-sub" id="winner-sub">Поздравляем!</div>
            <!-- mini board to illustrate final positions -->
            <div class="end-mini" id="end-mini" aria-hidden="false"></div>
            <div class="end-actions">
                <button id="btn-return-home" class="menu-btn primary">Вернуться на главную</button>
            </div>
        </div>
    </div>

    <script>
        // --- Helpers & state ---
        const tg = window.Telegram?.WebApp || {};
        try{ tg.expand?.() }catch(e){}
        try{ tg.ready?.() }catch(e){}

    // Попытка подключения к Socket.IO серверу
    const socket = io('https://vcbcbvcvbvcbv-cbvcklbcvkcvlkbcvlkcl-production.up.railway.app', {
        transports: ['websocket', 'polling'],
        upgrade: true,
        timeout: 10000,
        forceNew: true
    });

    // expose to window for diagnostic monkeypatches
    try{ window.socket = socket; }catch(e){}

    // debug monkeypatch removed in production
    try{ /* emit monkeypatch disabled */ }catch(e){}

    // Preload modal control: show for exactly 10s or random up to 10s
    function showPreload(options){
        // options: { random: boolean }
        const random = options && options.random;
        // determine duration
        let duration = 10;
        if (random){ duration = Math.max(1, Math.floor(Math.random()*10) ); }
        // show modal, hide sidebar
        try{ document.getElementById('preload-modal').style.display = 'flex'; }catch(e){}
        try{ document.querySelector('.app-sidebar').style.display = 'none'; }catch(e){}
    // show bottom-right spinner while preload is visible
    try{ document.getElementById('preload-bottom-spinner').style.display = 'flex'; }catch(e){}
        // ensure it's removed after exactly duration seconds even if tab hidden
        setTimeout(()=>{ try{ hidePreload(); }catch(e){} }, duration*1000 + 50);
        // attempt to load and play assets/loading.tgs (zlib-compressed lottie json)
        try{ playLoadingTgs(); }catch(e){ console.warn('playLoadingTgs err', e); }
    }

    function hidePreload(){
        try{ document.getElementById('preload-modal').style.display = 'none'; }catch(e){}
        try{ document.querySelector('.app-sidebar').style.display = ''; }catch(e){}
    try{ document.getElementById('preload-bottom-spinner').style.display = 'none'; }catch(e){}
    }

    // Play loading.tgs using pako + lottie-web
    let _preloadPlayer = null;
    async function playLoadingTgs(){
        const container = document.getElementById('preload-lottie');
        const imgFallback = document.getElementById('preload-tgs');
        const svgFallback = document.getElementById('preload-fallback');
        if (!container) return;
        // clear previous player
        try{ if (_preloadPlayer){ _preloadPlayer.destroy(); _preloadPlayer = null; } }catch(e){}
        // fetch binary
            try{
            console.info('playLoadingTgs: fetching /assets/loading.tgs');
            const resp = await fetch('/assets/loading.tgs');
            console.info('playLoadingTgs: fetch response', resp.status, resp.headers.get('content-type'));
            if (!resp.ok) throw new Error('failed to fetch tgs: ' + resp.status);
            const arrbuf = await resp.arrayBuffer();
            console.info('playLoadingTgs: fetched bytes=', arrbuf.byteLength);
            const uint8 = new Uint8Array(arrbuf);
            // Try to inflate (pako) then parse JSON
            try{
                console.info('playLoadingTgs: attempting pako.inflate');
                let inflated = null;
                try{
                    inflated = pako.inflate(uint8, { to: 'string' });
                    console.info('playLoadingTgs: pako.inflate ok, length=', inflated.length);
                }catch(e){
                    console.info('playLoadingTgs: pako.inflate failed, trying pako.ungzip', e && e.message);
                    try{
                        inflated = pako.ungzip(uint8, { to: 'string' });
                        console.info('playLoadingTgs: pako.ungzip ok, length=', inflated.length);
                    }catch(e2){
                        throw new Error('inflate+ungzip failed: ' + (e2 && e2.message));
                    }
                }
                const json = JSON.parse(inflated);
                console.info('playLoadingTgs: JSON parsed, version=', json.v || json.version || 'n/a');
                // create player
                _preloadPlayer = lottie.loadAnimation({ container: container, renderer: 'svg', loop: true, autoplay: true, animationData: json });
                console.info('playLoadingTgs: lottie player created');
                // ensure fallbacks hidden
                try{ if (imgFallback) imgFallback.style.display = 'none'; }catch(e){}
                try{ if (svgFallback) svgFallback.style.display = 'none'; }catch(e){}
                try{ const wrap = document.getElementById('preload-fallback-wrap'); if (wrap) wrap.style.display = 'none'; }catch(e){}
                container.style.display = 'flex';
                // quick check: if player created but hasn't rendered within 800ms, show fallback
                setTimeout(()=>{
                    try{
                        const playerSvg = container.querySelector('svg');
                        if (!playerSvg){ console.warn('playLoadingTgs: no svg in container after lottie init, showing fallback'); try{ const wrap = document.getElementById('preload-fallback-wrap'); if (wrap) wrap.style.display = 'flex'; container.style.display='none'; }catch(e){} }
                    }catch(e){ }
                }, 800);
                return;
            }catch(e){
                console.warn('TGS inflate/parse failed, falling back to image/SVG', e);
            }
            // if inflate failed, attempt to treat file as image
            try{
                const blob = new Blob([arrbuf]);
                const url = URL.createObjectURL(blob);
                if (imgFallback){ imgFallback.src = url; imgFallback.style.display = 'block'; }
                if (svgFallback) svgFallback.style.display = 'none';
                container.style.display = 'none';
                return;
            }catch(e){ console.warn('image fallback failed', e); }
        }catch(e){ console.warn('playLoadingTgs fetch error', e); }
        // final fallback: show svg
        try{ if (svgFallback) svgFallback.style.display = 'block'; if (container) container.style.display = 'none'; if (imgFallback) imgFallback.style.display = 'none'; }catch(e){}
    }

    // Добавляем обработчик ошибок подключения
    socket.on('connect_error', (error) => {
        console.error('Socket.IO connection error:', error);
        console.log('Trying alternative connection...');

        // Попытка альтернативного подключения
        socket.disconnect();
        window.altSocket = io('http://vcbcbvcvbvcbv-cbvcklbcvkcvlkbcvlkcl-production.up.railway.app', {
            transports: ['websocket', 'polling'],
            upgrade: true,
            timeout: 10000
        });

        // Копируем все обработчики событий на альтернативный сокет
        window.altSocket.on('connect', () => {
            console.log('Alternative socket connected successfully');
            // Заменяем основной сокет альтернативным
            Object.setPrototypeOf(window.altSocket, socket);
            socket = window.altSocket;
            delete window.altSocket;
        });
    });
        let currentUser = null;
        let activeLobby = null; // { id, lobby }
    // global reference to floating play button (may be created later on mobile)
    let playButton = null;
    let gameStarted = false;

        // init user from tg
        if (tg && tg.initDataUnsafe && tg.initDataUnsafe.user) {
            currentUser = { user_id: tg.initDataUnsafe.user.id, name: tg.initDataUnsafe.user.first_name || tg.initDataUnsafe.user.username || 'Игрок', avatar: '' };
            // notify server when connected
            updateProfile(currentUser);
            socket.emit('identify', currentUser);
        }

        // update sidebar/profile UI
        function updateProfile(user){
            try{
                const profileName = document.querySelector('.profile-name');
                const profileSub = document.querySelector('.profile-sub');
                const avatarEl = document.querySelector('.avatar');
                if (!profileName || !avatarEl) return;
                profileName.textContent = user.name || ('User' + (user.user_id||''));
                profileSub.textContent = user.user_id ? ('ID: ' + user.user_id) : '';
                avatarEl.innerHTML = '';
                if (user.avatar){ const img = document.createElement('img'); img.src = user.avatar; img.alt = user.name || 'Avatar'; avatarEl.appendChild(img); }
                else { avatarEl.textContent = (user.name||'').slice(0,1).toUpperCase(); }
            }catch(e){ console.error('updateProfile err', e); }
        }

        // --- Debug panel (visible in mini-app) ---
        function createDebugPanel(){
            // debug panel disabled in production
        }
            function appendDebugLine(msg){ /* disabled */ }

        // navigation lock helpers (used during quick-match searching/confirmation)
        function disableNavigation(){
            document.querySelectorAll('[data-action]').forEach(b=>{ try{ b.dataset._disabled = b.dataset.action; b.disabled = true; b.classList.add('disabled'); }catch(e){} });
            document.querySelectorAll('.bottom-nav button').forEach(b=>{ try{ b.disabled=true; b.classList.add('disabled'); }catch(e){} });
        }

        function enableNavigation(){
            document.querySelectorAll('[data-action]').forEach(b=>{ try{ b.disabled = false; b.classList.remove('disabled'); delete b.dataset._disabled; }catch(e){} });
            document.querySelectorAll('.bottom-nav button').forEach(b=>{ try{ b.disabled=false; b.classList.remove('disabled'); }catch(e){} });
        }

        socket.on('connect', ()=>{
            console.log('Socket connected successfully');
            if (currentUser) {
                console.log('Identifying user:', currentUser.user_id);
                socket.emit('identify', currentUser);
            }
            // refresh lobbies list when connect
            socket.emit('get_lobbies');
            // show auth modal if no init data from Telegram
            setTimeout(()=>{
                if (!(tg && tg.initDataUnsafe && tg.initDataUnsafe.user)) {
                    console.log('No Telegram user data found, showing auth modal');
                    openAuthModal();
                } else {
                    console.log('Telegram user data found, user is authenticated');
                }
            }, 250);
        });

        socket.on('disconnect', ()=>{
            console.log('Socket disconnected');
        });

        socket.on('connect_error', (error)=>{
            console.error('Socket connection error:', error);
        });

        // --- Authorization modal flow ---
        function openAuthModal(){
            document.getElementById('auth-modal').style.display = 'flex';
        }

        function closeAuthModal(){
            document.getElementById('auth-modal').style.display = 'none';
        }

        document.getElementById('btn-get-code').addEventListener('click', async ()=>{
            const sid = socket.id;
            try{
                const resp = await fetch('/auth_code', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ sid }) });
                const j = await resp.json();
                if (j.code){
                    document.getElementById('auth-code').value = j.code;
                    let msg = 'Код сгенерирован. Отправьте в бота: /start auth:' + j.code + '.';
                    if (j.bot_username){
                        const tlink = 'https://t.me/' + j.bot_username + '?start=auth:' + j.code;
                        msg += ' Или нажмите ссылку ниже, чтобы открыть чат с ботом.';
                        // render link button if not present
                        if (!document.getElementById('auth-open-tg')){
                            const wrap = document.createElement('div'); wrap.style.marginTop='8px';
                            const a = document.createElement('a'); a.id='auth-open-tg'; a.href = tlink; a.target='_blank'; a.className='menu-btn'; a.textContent = 'Открыть в Telegram'; a.style.display='inline-flex'; a.style.alignItems='center'; a.style.gap='8px';
                            wrap.appendChild(a);
                            document.getElementById('auth-modal').querySelector('div').appendChild(wrap);
                        }
                    }
                    document.getElementById('auth-state').textContent = msg;
                    document.getElementById('btn-auth-close').style.display = 'inline-flex';
                } else if (j.error) {
                    document.getElementById('auth-state').textContent = 'Ошибка: ' + j.error;
                }
            }catch(e){
                document.getElementById('auth-state').textContent = 'Ошибка сети при запросе кода';
            }
        });

        document.getElementById('btn-copy-code').addEventListener('click', ()=>{
            const code = document.getElementById('auth-code').value;
            if (!code) return;
            navigator.clipboard?.writeText(code).then(()=>{ document.getElementById('auth-state').textContent = 'Код скопирован в буфер обмена'; }).catch(()=>{ document.getElementById('auth-state').textContent = 'Не удалось скопировать'; });
        });

        // server will emit 'telegram_profile' when user authorizes via bot
        socket.on('telegram_profile', (profile)=>{
            try{
                if (profile && profile.user_id){
                    currentUser = { user_id: profile.user_id, name: profile.name || ('User' + profile.user_id), avatar: profile.avatar || '' };
                    updateProfile(currentUser);
                    document.getElementById('auth-state').textContent = 'Авторизация прошла успешно!';
                    setTimeout(()=>{ closeAuthModal(); }, 800);
                }
            }catch(e){ console.error('profile handle err', e) }
        });

        document.getElementById('btn-auth-close').addEventListener('click', ()=>{ closeAuthModal(); });

        // --- View routing ---
        function showView(name){
            document.querySelectorAll('.view').forEach(v=>{ v.style.display = v.dataset.view===name ? 'block' : 'none'; v.classList.remove('view-enter'); });
            const enter = document.querySelector(`[data-view="${name}"]`);
            if (enter) { enter.classList.add('view-enter'); }
            try{ /* view changed: '" + name + "' */ }catch(e){}
            // if search is active, reposition the floating/search indicator so it remains visible across view switches
            try{ if (searching){ const root = document.getElementById('search-indicator'); if (root && root.style.display !== 'none'){ /* re-run position logic: */
                        try{ const isMobileNow = window.matchMedia && window.matchMedia('(max-width:720px)').matches; if (isMobileNow){ /* keep current options */ } else { /* desktop: reposition under settings */ showSearchIndicator({}); } }catch(e){} }
                }
            }catch(e){}
            // update bottom nav active state (optional)
        }

        // wire navigation buttons
        document.querySelectorAll('[data-action]').forEach(btn=>btn.addEventListener('click', e=>{
            const a = e.currentTarget.dataset.action;
            // if in an active game, prevent navigating away
            if (activeLobby && activeLobby.status === 'playing') {
                // optionally show a toast / do nothing
                console.debug('navigation blocked: game in progress');
                return;
            }
            if (a==='go-home') showView('home');
            if (a==='go-lobby') { showView('lobby'); socket.emit('get_lobbies'); }
            if (a==='go-settings') showView('settings');
        }));

        // reauth button in settings
        (function(){
            const root = document.getElementById('view-settings');
            if (root){
                const btn = document.createElement('button'); btn.id='btn-reauth'; btn.className='menu-btn'; btn.textContent='Повторная авторизация';
                btn.style.marginTop='12px';
                btn.addEventListener('click', ()=>{ openAuthModal(); });
                root.appendChild(btn);
            }
        })();

        // Home actions: choose game or create lobby
        document.body.addEventListener('click', (e)=>{
            const choose = e.target.closest('.game-choose');
            const lobbyBtn = e.target.closest('.game-lobby');
            if (choose){
                const game = choose.dataset.game;
                if (game==='tictactoe') {
                    // quick create and wait for opponent: create lobby and stay
                    document.getElementById('lobby-name').value = `${currentUser?.name || 'Игрок'}'s lobby`;
                    showView('lobby');
                    // set focus to create button
                }
            }
            if (lobbyBtn){
                const game = lobbyBtn.dataset.game;
                showView('lobby');
            }
        });

        // Create lobby now opens a modal for settings
        document.getElementById('btn-create-lobby').addEventListener('click', ()=>{
            if (!currentUser || !currentUser.user_id) { openAuthModal(); return; }
            openCreateLobbyModal();
        });

        function openCreateLobbyModal(){
            // remove existing modal if any
            const existing = document.getElementById('create-lobby-modal'); if (existing) existing.remove();
            const overlay = document.createElement('div'); overlay.id = 'create-lobby-modal'; overlay.style.position='fixed'; overlay.style.inset='0'; overlay.style.display='flex'; overlay.style.alignItems='center'; overlay.style.justifyContent='center'; overlay.style.background='rgba(2,6,23,0.6)'; overlay.style.zIndex='1305';
            const box = document.createElement('div'); box.style.width='92%'; box.style.maxWidth='520px'; box.style.background='var(--card)'; box.style.border='1px solid rgba(255,255,255,0.04)'; box.style.borderRadius='12px'; box.style.padding='16px'; box.style.boxShadow='0 12px 40px rgba(2,6,23,0.6)';

            box.innerHTML = `<h3 style="margin:0 0 8px 0">Настройки лобби</h3>`;
            // visibility
            const visRow = document.createElement('div'); visRow.style.display='flex'; visRow.style.gap='8px'; visRow.style.marginTop='8px';
            const rbPublic = document.createElement('button'); rbPublic.className='menu-btn'; rbPublic.textContent='Публичное'; rbPublic.dataset.selected='true';
            const rbCode = document.createElement('button'); rbCode.className='menu-btn'; rbCode.textContent='По коду'; rbCode.dataset.selected='false';
            visRow.appendChild(rbPublic); visRow.appendChild(rbCode);
            box.appendChild(visRow);

            // game select (use available game cards)
            const gamesWrap = document.createElement('div'); gamesWrap.style.display='flex'; gamesWrap.style.gap='8px'; gamesWrap.style.marginTop='12px';
            const cards = document.querySelectorAll('.game-selection .game-card');
            cards.forEach(c=>{
                const gbtn = document.createElement('button'); gbtn.className='menu-btn'; gbtn.textContent = c.querySelector('h3')?.textContent || c.dataset.game || 'Игра'; gbtn.dataset.game = c.dataset.game || c.querySelector('h3')?.textContent || ''; gbtn.dataset.selected = 'false';
                gamesWrap.appendChild(gbtn);
                gbtn.addEventListener('click', ()=>{ gamesWrap.querySelectorAll('.menu-btn').forEach(b=>b.dataset.selected='false'); gbtn.dataset.selected='true'; gbtn.classList.add('primary'); gamesWrap.querySelectorAll('.menu-btn').forEach(b=>{ if (b!==gbtn) b.classList.remove('primary'); }); });
            });
            box.appendChild(gamesWrap);

            // lobby name
            const nameInput = document.createElement('input'); nameInput.placeholder = `${currentUser?.name || 'Игрок'}'s lobby`; nameInput.style.width='100%'; nameInput.style.marginTop='12px'; nameInput.style.padding='10px'; nameInput.style.borderRadius='10px'; nameInput.style.border='1px solid var(--glass)'; nameInput.style.background='transparent'; nameInput.style.color='var(--text)';
            box.appendChild(nameInput);

            // actions
            const actions = document.createElement('div'); actions.style.display='flex'; actions.style.justifyContent='flex-end'; actions.style.gap='8px'; actions.style.marginTop='12px';
            const btnCancel = document.createElement('button'); btnCancel.className='menu-btn'; btnCancel.textContent='Отмена';
            const btnCreate = document.createElement('button'); btnCreate.className='menu-btn primary'; btnCreate.textContent='Создать лобби';
            actions.appendChild(btnCancel); actions.appendChild(btnCreate);
            box.appendChild(actions);

            overlay.appendChild(box); document.body.appendChild(overlay);

            // toggle visibility buttons
            rbPublic.addEventListener('click', ()=>{ rbPublic.dataset.selected='true'; rbPublic.classList.add('primary'); rbCode.dataset.selected='false'; rbCode.classList.remove('primary'); });
            rbCode.addEventListener('click', ()=>{ rbCode.dataset.selected='true'; rbCode.classList.add('primary'); rbPublic.dataset.selected='false'; rbPublic.classList.remove('primary'); });

            btnCancel.addEventListener('click', ()=>{ overlay.remove(); });

            btnCreate.addEventListener('click', ()=>{
                // determine selected game
                let game = null; const gbtn = Array.from(gamesWrap.querySelectorAll('.menu-btn')).find(b=>b.dataset.selected==='true'); if (gbtn) game = gbtn.dataset.game || gbtn.textContent;
                const visibility = rbCode.dataset.selected==='true' ? 'code' : 'public';
                const name = nameInput.value.trim() || `${currentUser?.name || 'Игрок'}'s lobby`;
                // emit create_lobby with options
                socket.emit('create_lobby', { name, visibility, game, player_name: currentUser?.name || 'Игрок', player_avatar: currentUser?.avatar || '', user_id: currentUser?.user_id });
                // remove modal and show waiting UI
                overlay.remove();
                try{ SoundEngine.create(); }catch(e){}
            });
        }

        // render lobbies
        function renderLobbies(list){
            const root = document.getElementById('lobbies-list');
            root.innerHTML = '';
            if (!list || list.length===0) {
                root.innerHTML = '<div style="color:var(--muted);padding:12px;border-radius:10px;border:1px dashed rgba(255,255,255,0.03)">Лобби ещё нет. Создайте своё!</div>';
                return;
            }

            // limit visible lobbies to first 10
            const visible = list.slice(0, 10);
            visible.forEach(lobby=>{
                const el = document.createElement('div');
                el.className = 'lobby-card';

                const avatar = document.createElement('div');
                avatar.className = 'lobby-avatar';
                // if avatar available from lobby.players[0].avatar use img, else show initial
                const firstPlayer = (lobby.players && lobby.players[0]) ? lobby.players[0] : null;
                if (firstPlayer && firstPlayer.avatar) {
                    const img = document.createElement('img'); img.src = firstPlayer.avatar; img.alt = firstPlayer.name || 'Игрок';
                    avatar.innerHTML = ''; avatar.appendChild(img);
                } else {
                    const initial = (lobby.name||'L').trim().slice(0,1).toUpperCase();
                    avatar.textContent = initial;
                }

                const info = document.createElement('div');
                info.className = 'lobby-info';
                info.innerHTML = `<div class="lobby-name">${escapeHtml(lobby.name || 'Лобби')}</div><div class="lobby-meta">Игроков: ${lobby.players?.length||0} • ${escapeHtml(lobby.status||'—')}</div>`;

                const actions = document.createElement('div');
                actions.className = 'lobby-actions';

                const statusBadge = document.createElement('div');
                statusBadge.className = 'badge ' + (lobby.status==='playing' ? 'playing' : 'wait');
                statusBadge.textContent = lobby.status==='playing' ? 'Игра' : 'Ожидание';

                const join = document.createElement('button'); join.className='menu-btn'; join.textContent = lobby.players && lobby.players.length>=2 ? 'Полное' : 'Войти';
                if (lobby.players && lobby.players.length>=2) join.disabled = true;
                join.addEventListener('click', ()=>{
                    if (!currentUser || !currentUser.user_id) { openAuthModal(); return; }
                    // prevent joining own lobby
                    const youIn = (lobby.players||[]).some(p=>p.user_id === currentUser.user_id || p.sid === socket.id);
                    if (youIn) { alert('Вы уже в этом лобби'); return; }
                    socket.emit('join_lobby', { lobby_id: lobby.id, player_name: currentUser?.name, player_avatar: currentUser?.avatar, user_id: currentUser?.user_id });
                });

                actions.appendChild(statusBadge);
                actions.appendChild(join);

                el.appendChild(avatar);
                el.appendChild(info);
                el.appendChild(actions);

                root.appendChild(el);
            });
        }

        socket.on('lobbies_list', (list)=>{ renderLobbies(list); });
        // when a quick-match hidden lobby is started, server emits 'lobby_started' with lobby data
        socket.on('lobby_started', (lobby)=>{
            gameStarted = true;
            try{
                console.debug('socket:lobby_started', lobby);
                try{ console.debug('lobby_started: ' + JSON.stringify({ id: lobby?.id, status: lobby?.status, hasPlayers: Array.isArray(lobby?.players) ? lobby.players.length : 0 })); }catch(e){}
                if (!lobby) return;

                // If server sent only minimal data (id/status) without players/board, request a fuller update
                // attempt to use cached match_starting players if lobby_started lacks players
                let hasPlayers = Array.isArray(lobby.players) && lobby.players.length;
                const hasBoard = !!lobby.board;
                if (!hasPlayers && lobby.id && lastMatchStarts && lastMatchStarts[lobby.id]){
                    try{ /* merging players from recent match_starting cache */ }catch(e){}
                    const cached = lastMatchStarts[lobby.id];
                    try{ lobby.players = Array.isArray(cached) ? cached.map(p => (typeof p==='string' ? { name: p } : p)) : lobby.players; }catch(e){}
                    // recompute after merge
                    hasPlayers = Array.isArray(lobby.players) && lobby.players.length;
                }
                if (!hasPlayers && !hasBoard) {
                    try{ /* incomplete payload — waiting briefly for match_starting then requesting lobbies update */ }catch(e){}
                    // wait a short moment for a concurrent match_starting to arrive, then request lobbies if still incomplete
                    setTimeout(()=>{
                        if (!(Array.isArray(lobby.players) && lobby.players.length) && !lobby.board) {
                            try{ socket.emit('get_lobbies'); }catch(e){}
                        } else {
                            try{ /* received additional data during wait */ }catch(e){}
                        }
                    }, 350);
                    // keep confirm modal visible until we receive a proper update
                    return;
                }

                // we have a full lobby payload — proceed to transition
                try{ console.debug('lobby_started: full payload: ' + JSON.stringify(lobby)); }catch(e){}
                try{ hideSearchIndicator(); }catch(e){ console.warn('lobby_started: hideSearchIndicator threw: '+(e&&e.message)); }
                try{ document.getElementById('confirm-modal').style.display = 'none'; }catch(e){ console.warn('lobby_started: hide confirm-modal threw: '+(e&&e.message)); }
                if (confirmCountdown){ clearInterval(confirmCountdown); confirmCountdown=null; }
                try{ if (playButton) playButton.style.pointerEvents = ''; }catch(e){ console.warn('lobby_started: restoring playButton threw: '+(e&&e.message)); }
                searching = false;
                try{ enableNavigation(); }catch(e){ console.warn('lobby_started: enableNavigation threw: '+(e&&e.message)); }

                // set active lobby and show game
                try{
                    /* about to set activeLobby and call showLobby/showView */
                }catch(e){}
                try{
                    activeLobby = lobby;
                }catch(e){ try{ appendDebugLine('lobby_started: set activeLobby failed: '+(e&&e.message)); }catch(_){} }
                try{
                    showLobby(activeLobby);
                }catch(e){ console.warn('lobby_started: showLobby threw: '+(e&&e.message)); }
                try{
                    showView('game');
                }catch(e){ console.warn('lobby_started: showView("game") threw: '+(e&&e.message)); }
                try{ SoundEngine.lobbyCreated(); }catch(e){ console.warn('lobby_started: SoundEngine.lobbyCreated threw: '+(e&&e.message)); }
            }catch(e){ console.error(e); }
        });
            // Diagnostic handlers: match lifecycle events
            // cache last match_starting per lobby to help when lobby_started is minimal
            const lastMatchStarts = {};
            // client-side search tracking to avoid stale events updating confirm UI
            let lastSearchStart = 0; // timestamp ms when client started quick_match
            let lastSearchGame = null;
            const processedMatchIds = new Set();

            function _normalizePlayer(p){
                if (!p) return null;
                // accept only if contains a visible identifier
                if ((p.name && String(p.name).trim() !== '') || (p.avatar && String(p.avatar).trim() !== '') || p.user_id || p.sid) return p;
                return null;
            }
            socket.on('match_starting', (payload)=>{
            try{
                console.info('socket:match_starting', payload);
                try{ /* match_starting received */ }catch(e){}
                    // store raw players array (could be array of strings)
                        try{ if (payload && payload.lobby_id) lastMatchStarts[payload.lobby_id] = payload.players || payload.lobby?.players || null; }catch(e){}
                // if confirm modal is open, update players with normalized payload
                    // Only update the confirm modal when this client recently initiated a search
                    const recentSearch = (Date.now() - (lastSearchStart || 0)) < 60000; // 60s window
                    if (payload && payload.players && payload.players.length && recentSearch){
                    const players = payload.players;
                    // try to place current user on left
                    const meIdx = players.findIndex(p => p.user_id === currentUser?.user_id || p.sid === socket.id);
                    let a = null, b = null;
                    if (meIdx === -1){ a = { name: currentUser?.name || 'Вы', avatar: currentUser?.avatar || '' }; b = players[0]; }
                    else { a = players[meIdx]; b = players[(meIdx===0?1:0)] || null; }
                        // normalize players to avoid showing empty/unknown opponent
                        a = _normalizePlayer(a) || { name: currentUser?.name || 'Вы', avatar: currentUser?.avatar || '' };
                        b = _normalizePlayer(b) || null;
                        try{ const ava = document.getElementById('confirm-avatar-a'); ava.innerHTML=''; if (a && a.avatar){ const img=document.createElement('img'); img.src=a.avatar; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover'; ava.appendChild(img); } else { ava.textContent = (a && a.name? (a.name||'').slice(0,1).toUpperCase() : '—'); } }catch(e){}
                        try{ document.getElementById('confirm-name-a').textContent = a && a.name ? a.name : 'Вы'; }catch(e){}
                        try{ const bv = document.getElementById('confirm-avatar-b'); bv.innerHTML=''; if (b && b.avatar){ const img2=document.createElement('img'); img2.src=b.avatar; img2.style.width='100%'; img2.style.height='100%'; img2.style.objectFit='cover'; bv.appendChild(img2); } else { bv.textContent = (b && b.name? (b.name||'').slice(0,1).toUpperCase() : '—'); } }catch(e){}
                        try{ document.getElementById('confirm-name-b').textContent = b && b.name ? b.name : 'Ожидание'; }catch(e){}
                }
            }catch(e){ console.warn('match_starting handler err', e); }
        });

        socket.on('match_ack', (data)=>{
            try{ console.info('socket:match_ack', data); }catch(e){}
        });

        socket.on('match_cancelled', (data)=>{
            try{ console.info('socket:match_cancelled', data); hideSearchIndicator(); document.getElementById('confirm-modal').style.display = 'none'; if (confirmCountdown){ clearInterval(confirmCountdown); confirmCountdown=null; } enableNavigation(); }catch(e){}
        });
    // inline search indicator and play button toggle state
    let searching = false;
    let searchStart = 0;
    let searchTimer = null;
    // long-search UI timer
    let searchLongTimer = null;

        // helper to expand/collapse the extra panel
        function _toggleSearchExpanded(root, expand){
            try{
                const exp = root.querySelector('.search-expanded');
                const arrow = root.querySelector('#search-arrow');
                const bar = root.querySelector('.search-bar');
                if (!exp) return;
                if (expand){
                    exp.classList.add('expanded');
                    if (arrow) arrow.style.transform = 'rotate(180deg)';
                    if (bar) bar.setAttribute('aria-expanded','true');
                } else {
                    exp.classList.remove('expanded');
                    if (arrow) arrow.style.transform = 'rotate(0deg)';
                    if (bar) bar.setAttribute('aria-expanded','false');
                }
            }catch(e){ }
        }

        function showSearchIndicator(opts = {}){
                // opts: { game, player: { name, avatar }, foundCount }
            if (!searching){ searching = true; searchStart = Date.now(); }
            const root = document.getElementById('search-indicator');
            if (!root) return;
            root.style.display = 'block';
            // ensure collapsed by default
            try{ _toggleSearchExpanded(root, false); }catch(e){}
            // position: if mobile -> attach to top of left menu; if desktop -> show in top-right area after settings
            try{
                const isMobileNow = window.matchMedia && window.matchMedia('(max-width:720px)').matches;
                if (isMobileNow){
                    // anchor to bottom navigation area: place indicator just above bottom-nav and stretch to match its width
                    const bottomNav = document.querySelector('.bottom-nav');
                    if (bottomNav){
                        const bnRect = bottomNav.getBoundingClientRect();
                        root.style.position = 'fixed';
                        root.style.left = (bnRect.left + 12) + 'px';
                        root.style.width = Math.max(240, bnRect.width - 24) + 'px';
                        // place just above bottom nav (account safe-area inset)
                        root.style.bottom = (window.innerHeight - bnRect.top + 8) + 'px';
                        root.style.top = 'auto'; root.style.transform = 'none';
                        // style as blue pill
                        try{ root.querySelector('.search-bar').style.background = 'linear-gradient(90deg,#6b8cff,#5a6bd8)'; }catch(e){}
                        try{ const exp = root.querySelector('.search-expanded'); if (exp){ exp.style.transformOrigin = 'bottom'; } }catch(e){}
                    } else {
                        // fallback: center above the bottom area
                        root.style.position = 'fixed'; root.style.left='50%'; root.style.transform='translateX(-50%)'; root.style.bottom='120px';
                    }
                } else {
                    // desktop: prefer anchoring the indicator inside the left sidebar area (where user highlighted)
                    const sidebar = document.querySelector('.app-sidebar');
                    if (sidebar){
                        const sbRect = sidebar.getBoundingClientRect();
                        root.style.position = 'fixed';
                        root.style.left = (sbRect.left + 12) + 'px';
                        // place a bit below the top of sidebar content area
                        root.style.top = (sbRect.top + 12) + 'px';
                        root.style.width = Math.max(220, sbRect.width - 24) + 'px';
                        root.style.transform = 'none';
                        // style as blue pill (mobile-like) but larger and with full data
                        try{ const bar = root.querySelector('.search-bar'); if (bar) { bar.style.background = 'linear-gradient(90deg,#6b8cff,#5a6bd8)'; bar.style.color = '#07102a'; bar.style.justifyContent='space-between'; } }catch(e){}
                        // mark desktop anchored so CSS can switch layout
                        root.dataset.desktop = '1';
                        // ensure expanded view is visible and rendered inline (full data under the pill)
                        try{ const exp = root.querySelector('.search-expanded'); if (exp){ exp.classList.add('expanded'); exp.style.position = 'relative'; exp.style.bottom = 'auto'; exp.style.left='0'; exp.style.right='0'; exp.style.transform='none'; exp.style.opacity = '1'; exp.style.pointerEvents='auto'; exp.style.display = 'block'; exp.style.maxHeight = '140px'; exp.style.overflow = 'auto'; } }catch(e){}
                        // position the indicator to exactly cover the menu-buttons area (so it doesn't touch the profile)
                        try{
                            const menuButtons = sidebar.querySelector('.menu-buttons');
                            if (menuButtons){
                                const mbRect = menuButtons.getBoundingClientRect();
                                    // Position the search card under the Settings button so profile stays visible
                                    const settingsBtn = sidebar.querySelector('.menu-buttons [data-action="go-settings"]');
                                    const gap = 8; // small gap under settings button
                                    let topStart = mbRect.top;
                                    try{
                                        if (settingsBtn){ const sb = settingsBtn.getBoundingClientRect(); topStart = sb.bottom + gap; }
                                    }catch(e){}
                                // compute available space down to bottom of sidebar so we don't overflow the layout
                                const sbRect = sidebar.getBoundingClientRect();
                                const availableSpace = Math.max(80, Math.floor(sbRect.bottom - topStart - 12));
                                const extraDown = 36; // ~3 clicks height
                                const desiredHeight = Math.min( Math.max(56, Math.floor(mbRect.height) + extraDown), availableSpace );
                                root.style.top = (topStart) + 'px';
                                root.style.height = desiredHeight + 'px';
                                // do NOT hide menu buttons; keep them visible as requested
                                // set expanded area to use available space (avoid inner scroll where possible)
                                const exp = root.querySelector('.search-expanded'); if (exp){ exp.style.maxHeight = (desiredHeight - 8) + 'px'; exp.style.overflow = 'auto'; }
                            }
                        }catch(e){}
                    } else {
                        // fallback: original settingsBtn behaviour
                        const settingsBtn = document.querySelector('.bottom-settings');
                        if (settingsBtn){
                            const rect = settingsBtn.getBoundingClientRect();
                            root.style.position = 'fixed';
                            root.style.left = (rect.right + 12) + 'px';
                            root.style.top = (rect.top) + 'px';
                            root.style.width = '260px';
                            root.style.transform = 'none';
                            try{ const bar = root.querySelector('.search-bar'); if (bar) { bar.style.background = 'rgba(6,18,46,0.88)'; bar.style.color = 'var(--text)'; } }catch(e){}
                            _toggleSearchExpanded(root, true);
                        }
                    }
                }
            }catch(e){}
            // update game text
            try{
                let gameName = opts.game || null;
                if (!gameName){ const sel = document.querySelector('.game-selection .game-card.selected'); if (sel) gameName = sel.querySelector('h3')?.textContent || sel.dataset.game; }
                const g = root.querySelector('#search-game-text'); if (g) g.textContent = 'Игра: ' + (gameName || '—');
            }catch(e){}
            // update player avatar + name
            try{
                const av = root.querySelector('#search-player-avatar');
                if (av){ av.innerHTML = ''; if (opts.player && opts.player.avatar){ const img = document.createElement('img'); img.src = opts.player.avatar; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover'; av.appendChild(img); } else { av.textContent = (opts.player && opts.player.name ? (opts.player.name||'').slice(0,1).toUpperCase() : '—'); } }
                const pn = root.querySelector('#search-player-name'); if (pn) pn.textContent = (opts.player && opts.player.name ? opts.player.name : '—');
            }catch(e){}
            // update found count
            try{ const fc = Math.max(1, Number(opts.foundCount) || 0); const ff = root.querySelector('#search-found-text'); if (ff) ff.textContent = 'Игроков найдено: ' + fc; }catch(e){}
            // reset long-search label and start 15s timer to show it with animation
            try{ const lt = root.querySelector('#search-long-text'); if (lt) { lt.style.display = 'none'; lt.style.opacity = '0'; lt.style.transform = 'translateY(6px)'; } }catch(e){}
            try{ if (searchLongTimer) clearTimeout(searchLongTimer); }catch(e){}
            searchLongTimer = setTimeout(()=>{ try{
                    const bar = root.querySelector('.search-bar');
                    if (bar){
                        // save any inline background so we can restore it later
                        try{ bar.dataset._prevBg = bar.style.background || ''; bar.dataset._prevColor = bar.style.color || ''; }catch(e){}
                        // set yellow background inline to override any CSS
                        try{ bar.style.background = 'linear-gradient(90deg,#ffd166,#ffd166)'; bar.style.color = '#07102a'; }catch(e){}
                        bar.classList.add('long-search');
                    }
                    // highlight only active per-card play buttons (those with data-searching='1')
                    try{
                        const activeBtns = Array.from(document.querySelectorAll('.card-play-btn')).filter(b=>b && b.dataset && b.dataset.searching === '1');
                        if (activeBtns && activeBtns.length){ activeBtns.forEach(b=>{ b.classList.add('long-search'); b.style.background = '#ffd166'; b.style.color = '#07102a'; b.style.borderColor = 'rgba(0,0,0,0.06)'; }); }
                    }catch(e){}
                    // reveal expanded 'Долгий поиск' text and also animate alt title inside pill
                    const lt = root.querySelector('#search-long-text'); if (lt){ lt.style.display='block'; lt.style.opacity='1'; lt.style.transform='translateY(0)'; }
                    try{ const titleEl = root.querySelector('#search-title'); if (titleEl) titleEl.textContent = 'Долгий поиск'; }catch(e){}
                    try{ const altEl = root.querySelector('#search-alt-title'); if (altEl) altEl.style.display = 'none'; }catch(e){}
                    // change button text to 'Долгий поиск'
                    try{ playButton.textContent = 'Долгий поиск'; }catch(e){}
                    try{ document.querySelectorAll('.card-play-btn').forEach(b=>{ if (b.dataset.searching === '1') b.textContent = 'Долгий поиск'; }); }catch(e){}
                    // on mobile, expand the search indicator to show the long search text
                    if (root.dataset.desktop !== '1') { _toggleSearchExpanded(root, true); }
                }catch(e){} }, 15000);
            playButton.textContent = 'Отменить';
            playButton.classList.add('visible');
            playButton.setAttribute('aria-hidden','false');
            disableNavigation();
            // start timer update
            if (searchTimer) clearInterval(searchTimer);
            (function update(){
                const elapsed = Math.floor((Date.now() - searchStart)/1000);
                const mm = String(Math.floor(elapsed/60)).padStart(2,'0');
                const ss = String(elapsed % 60).padStart(2,'0');
                try{ const tt = root.querySelector('#search-timer-text'); if (tt) tt.textContent = `Поиск: ${mm}:${ss}`; }catch(e){}
            })();
            searchTimer = setInterval(()=>{
                const elapsed = Math.floor((Date.now() - searchStart)/1000);
                const mm = String(Math.floor(elapsed/60)).padStart(2,'0');
                const ss = String(elapsed % 60).padStart(2,'0');
                try{ const tt = root.querySelector('#search-timer-text'); if (tt) tt.textContent = `Поиск: ${mm}:${ss}`; const compact = root.querySelector('#search-timer-compact'); if (compact) compact.textContent = `${mm}:${ss}`; }catch(e){}
            }, 500);
            // attach one-time handlers for toggle if not already attached
            try{
                    if (!root.dataset.toggleAttached){
                        const bar = root.querySelector('.search-bar');
                        const collapseBtn = root.querySelector('#search-collapse-btn');
                        if (bar){
                            // Always attach handler, but only toggle in mobile view (so mobile click works).
                            bar.addEventListener('click', ()=>{
                                const isMobileNow = window.matchMedia && window.matchMedia('(max-width:720px)').matches;
                                if (!isMobileNow) return; // desktop: do not toggle (static)
                                const expanded = bar.getAttribute('aria-expanded') === 'true'; _toggleSearchExpanded(root, !expanded);
                            });
                            // touchstart for mobile reliability
                            bar.addEventListener('touchstart', (ev)=>{ const isMobileNow = window.matchMedia && window.matchMedia('(max-width:720px)').matches; if (!isMobileNow) return; ev.stopPropagation(); const expanded = bar.getAttribute('aria-expanded') === 'true'; _toggleSearchExpanded(root, !expanded); }, { passive: true });
                            bar.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); bar.click(); } });
                        }
                        if (collapseBtn) collapseBtn.addEventListener('click', ()=>{ _toggleSearchExpanded(root, false); });
                        root.dataset.toggleAttached = '1';
                    }
            }catch(e){}
        }

        function hideSearchIndicator(){
            searching = false;
            const root = document.getElementById('search-indicator');
            if (root){
                try{ _toggleSearchExpanded(root, false); }catch(e){}
                try{ root.style.display = 'none'; }catch(e){}
                try{ 
                    // clear desktop anchoring and restore defaults
                    // restore menu-buttons visibility if we hid it earlier
                    try{ const sidebar = document.querySelector('.app-sidebar'); if (sidebar){ const menuButtons = sidebar.querySelector('.menu-buttons'); if (menuButtons && menuButtons.dataset._wasHiddenBySearch){ menuButtons.style.display = menuButtons.dataset._prevDisplay || ''; menuButtons.style.visibility = menuButtons.dataset._prevVisibility || ''; delete menuButtons.dataset._wasHiddenBySearch; delete menuButtons.dataset._prevDisplay; delete menuButtons.dataset._prevVisibility; } } }catch(e){}
                    root.dataset.desktop = '';
                    const exp = root.querySelector('.search-expanded'); 
                    if (exp){ exp.classList.remove('expanded'); exp.style.position = ''; exp.style.bottom = ''; exp.style.left = ''; exp.style.right = ''; exp.style.transform = ''; exp.style.opacity = ''; exp.style.pointerEvents = ''; exp.style.display = 'none'; exp.style.maxHeight = ''; exp.style.overflow = ''; }
                    // reset search-bar styles
                    try{ const bar = root.querySelector('.search-bar'); if (bar){ bar.style.background=''; bar.style.color=''; bar.style.justifyContent=''; } }catch(e){}
                }catch(e){}
            }
            // reset any per-card buttons searching state
            try{ document.querySelectorAll('.card-play-btn').forEach(b=>{ b.dataset.searching='0'; b.textContent='Играть'; b.classList.remove('danger'); b.classList.add('primary'); b.style.background=''; b.style.color=''; b.style.borderColor=''; }); }catch(e){}
            try{ if (searchLongTimer) clearTimeout(searchLongTimer); }catch(e){}
            try{ const lt = document.getElementById('search-long-text'); if (lt) { lt.style.display = 'none'; lt.style.opacity='0'; } }catch(e){}
            try{ const root = document.getElementById('search-indicator'); const bar = root && root.querySelector('.search-bar'); if (bar) bar.classList.remove('long-search'); }catch(e){}
            try{ if (playButton) playButton.classList.remove('long-search'); }catch(e){}
            try{ document.querySelectorAll('.card-play-btn').forEach(b=>b.classList.remove('long-search')); }catch(e){}
            if (searchTimer) { clearInterval(searchTimer); searchTimer = null; }
            playButton.textContent = 'Играть';
            playButton.classList.remove('visible');
            playButton.setAttribute('aria-hidden','true');
            enableNavigation();
            // reset dynamic fields
            try{ const titleEl = root.querySelector('#search-title'); if (titleEl) { titleEl.textContent = 'Поиск'; titleEl.style.transform = ''; titleEl.style.opacity = ''; } }catch(e){}
            try{ const altEl = root.querySelector('#search-alt-title'); if (altEl) { altEl.style.display = ''; altEl.style.transform = ''; altEl.style.opacity = '0'; } }catch(e){}
        }

    socket.on('lobby_waiting', (data)=>{
        try{
            console.log('Game search in progress:', data);
            try{ /* lobby_waiting */ }catch(e){}
            const found = (data && Array.isArray(data.players) ? data.players.length : (typeof data?.foundCount !== 'undefined' ? Number(data.foundCount) : 1));
            const opts = { game: data?.game || data?.name || null, player: { name: currentUser?.name, avatar: currentUser?.avatar }, foundCount: found };
            showSearchIndicator(opts);
        }catch(e){
            console.error('Error handling lobby_waiting:', e);
        }
    });

    socket.on('lobby_cancelled', (data)=>{
        try{
            console.debug('socket:lobby_cancelled', data);
            try{ /* lobby_cancelled */ }catch(e){}
            try{ if (data && data.lobby_id) delete lastMatchStarts[data.lobby_id]; }catch(e){}
            lastSearchStart = 0; lastSearchGame = null;
            processedMatchIds.clear();
            hideSearchIndicator();
        }catch(e){}
    });

    // Добавляем обработчик для подтверждения получения сервером события quick_match
    socket.on('quick_match_received', (data) => {
        console.log('Server received quick_match event:', data);
    try{ /* quick_match_received */ }catch(e){}
    });

    // server notifies when a player forfeits — show end screen immediately
    socket.on('player_forfeited', (data)=>{
        try{
            /* player_forfeited */
            // if we have an activeLobby, mark it finished and show end screen
            if (activeLobby && activeLobby.id){
                activeLobby.status = 'finished';
                // server may have set lobby.winner symbol already via update_lobby; prefer that
                const winnerSym = (activeLobby.winner || data.winner_symbol || null);
                activeLobby.winner = winnerSym;
                // infer winner name/avatar from players
                let winnerName = '';
                let winnerAvatar = '';
                try{
                    const pl = (activeLobby.players||[]).find(p => (p.symbol === winnerSym));
                    if (pl){ winnerName = pl.name || ''; winnerAvatar = pl.avatar || ''; }
                }catch(e){}
                showLobby(activeLobby);
                showEndScreen({ winner: winnerSym, name: winnerName, avatar: winnerAvatar, board: activeLobby.board });
            } else {
                /* player_forfeited: no activeLobby, ignoring */
            }
        }catch(e){ console.warn('player_forfeited handler err', e); }
    });

        // server-side admin reset: force clients to clear local profile and show auth modal
        socket.on('force_logout', (data)=>{
            try{
                console.info('socket:force_logout', data);
                currentUser = null;
                updateProfile({ name: 'Гость', avatar: '' });
                openAuthModal();
            }catch(e){ console.warn('force_logout handler error', e); }
        });

        

        // match found confirmation flow
        let confirmCountdown = null;
    socket.on('match_found', (payload)=>{
                try{
                    console.debug('socket:match_found', payload);
                    // avoid processing stale or duplicate match events
                    const mid = payload && payload.match_id;
                    const recentSearch = (Date.now() - (lastSearchStart || 0)) < 60000;
                    if (mid && processedMatchIds.has(mid)) { return; }
                    if (!recentSearch) { return; }
                    if (mid) processedMatchIds.add(mid);
                    // show blocking confirm modal (keep it on top)
                    document.getElementById('confirm-modal').style.display = 'flex';
                try{ SoundEngine.matchFound(); }catch(e){}
                    // while waiting for confirmation, ensure navigation is disabled
                    disableNavigation();
                    // disable play button interactions underneath modal
                    try{ if (playButton) playButton.style.pointerEvents = 'none'; }catch(e){}
                    let timeLeft = 30;
                    document.getElementById('confirm-timer').textContent = String(timeLeft);
                    // start countdown
                    if (confirmCountdown) clearInterval(confirmCountdown);
                    confirmCountdown = setInterval(()=>{
                        timeLeft -= 1;
                        document.getElementById('confirm-timer').textContent = String(timeLeft);
                        if (timeLeft <= 0){
                            clearInterval(confirmCountdown); confirmCountdown = null;
                            // Time expired on client — close modal and re-enable navigation.
                            // Server-side timeout will decide requeue/cancel and notify clients.
                            document.getElementById('confirm-modal').style.display = 'none';
                            try{ if (playButton) playButton.style.pointerEvents = ''; }catch(e){}
                            enableNavigation();
                        }
                    }, 1000);

                    // populate players info in modal
                    try{
                        // payload may contain: lobby.players: [{name,avatar,user_id,sid}], or payload.players, or player_a/player_b, or opponent
                        let a = null, b = null;
                        const playersArr = Array.isArray(payload?.lobby?.players) ? payload.lobby.players : (Array.isArray(payload?.players) ? payload.players : null);
                        if (Array.isArray(playersArr) && playersArr.length >= 1){
                            // find current user among players (by user_id or sid)
                            const meIdx = playersArr.findIndex(p=>p.user_id === currentUser?.user_id || p.sid === socket.id);
                            if (meIdx === -1){
                                // if we don't see ourselves, prefer to show currentUser on left
                                a = { name: currentUser?.name || 'Вы', avatar: currentUser?.avatar || '', user_id: currentUser?.user_id };
                                b = playersArr[0];
                            } else {
                                a = playersArr[meIdx];
                                b = playersArr[(meIdx === 0 ? 1 : 0)] || null;
                            }
                        } else if (payload.player_a || payload.player_b) {
                            a = payload.player_a || { name: currentUser?.name || 'Вы', avatar: currentUser?.avatar || '', user_id: currentUser?.user_id };
                            b = payload.player_b || payload.opponent || null;
                        } else if (payload.opponent) {
                            a = { name: currentUser?.name || 'Вы', avatar: currentUser?.avatar || '', user_id: currentUser?.user_id };
                            b = payload.opponent;
                        } else {
                            a = { name: currentUser?.name || 'Вы', avatar: currentUser?.avatar || '', user_id: currentUser?.user_id };
                            b = null;
                        }

                        // fill left
                        try{ const ava = document.getElementById('confirm-avatar-a'); ava.innerHTML = ''; if (a && a.avatar){ const img=document.createElement('img'); img.src=a.avatar; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover'; ava.appendChild(img); } else { ava.textContent = (a && a.name? (a.name||'').slice(0,1).toUpperCase() : '—'); } }catch(e){}
                        try{ document.getElementById('confirm-name-a').textContent = a && a.name ? a.name : 'Вы'; }catch(e){}

                        // fill right
                        try{ const bv = document.getElementById('confirm-avatar-b'); bv.innerHTML = ''; if (b && b.avatar){ const img2=document.createElement('img'); img2.src=b.avatar; img2.style.width='100%'; img2.style.height='100%'; img2.style.objectFit='cover'; bv.appendChild(img2); } else { bv.textContent = (b && b.name? (b.name||'').slice(0,1).toUpperCase() : '—'); } }catch(e){}
                        try{ document.getElementById('confirm-name-b').textContent = b && b.name ? b.name : 'Ожидание'; }catch(e){}
                    }catch(e){ console.warn('confirm players populate err', e); }

                    // Ensure buttons/waiting state reflects server 'confirmed' list (so if user already confirmed on another device we show waiting)
                    try{
                        const buttonsEl = document.getElementById('confirm-buttons');
                        const waitingEl = document.getElementById('confirm-waiting');
                        // default: show buttons, hide waiting
                        if (buttonsEl) buttonsEl.style.display = 'flex';
                        if (waitingEl) waitingEl.style.display = 'none';
                        try{
                            const confirmedArr = Array.isArray(payload?.confirmed) ? payload.confirmed : [];
                            let alreadyConfirmed = false;
                            // payload.confirmed may contain user_key strings like 'uid:<id>' or socket ids
                            if (Array.isArray(confirmedArr) && confirmedArr.length){
                                const myUidKey = currentUser?.user_id ? `uid:${currentUser.user_id}` : null;
                                for (let ci=0; ci<confirmedArr.length; ci++){
                                    const v = String(confirmedArr[ci]);
                                    if ((myUidKey && v === myUidKey) || v === socket.id || v === String(currentUser?.user_id)){
                                        alreadyConfirmed = true; break;
                                    }
                                }
                            }
                            if (alreadyConfirmed){ if (buttonsEl) buttonsEl.style.display='none'; if (waitingEl) waitingEl.style.display='block'; }
                        }catch(e){}
                    }catch(e){}

                    // accept/decline handlers
                    document.getElementById('btn-accept').onclick = ()=>{
                        // Send accept but KEEP the modal visible; hide buttons and show waiting text
                        socket.emit('match_accept', { match_id: payload.match_id, user_id: currentUser?.user_id });
                        // Hide action buttons and show waiting message
                        try{ document.getElementById('confirm-buttons').style.display = 'none'; }catch(e){}
                        try{ document.getElementById('confirm-waiting').style.display = 'block'; }catch(e){}
                        // keep timer visible but make it non-interactive (it's behind the modal now)
                    };
                    // No decline button: user may simply wait out the timeout to decline implicitly.
                }catch(e){ console.error(e); }
        });

    socket.on('match_cancelled', (data)=>{ try{ console.debug('socket:match_cancelled', data);
        // clear related caches and UI
        try{ if (data && data.lobby_id) delete lastMatchStarts[data.lobby_id]; }catch(e){}
        lastSearchStart = 0; lastSearchGame = null;
        processedMatchIds.clear();
        hideSearchIndicator(); document.getElementById('confirm-modal').style.display = 'none'; if (confirmCountdown){ clearInterval(confirmCountdown); confirmCountdown=null; } enableNavigation(); }catch(e){} });
        socket.on('lobby_created', (data)=>{
            // server returns lobby_id and lobby
            const lobby = data.lobby || data;
            // show lobby view and join room locally by id
            // We already are creator; server registered player
            try{ if (lobby && lobby.id) delete lastMatchStarts[lobby.id]; }catch(e){}
            lastSearchStart = 0; lastSearchGame = null; processedMatchIds.clear();
            activeLobby = lobby;
            // show preload BEFORE showing game
            try{ showPreload({ random: false }); }catch(e){}
            // after preload hides, show lobby and game view
            setTimeout(()=>{ try{ showLobby(activeLobby); showView('game'); }catch(e){} }, 10100);
            try{ SoundEngine.lobbyCreated(); }catch(e){}
            // clear any quick-match UI and allow navigation
            hideSearchIndicator();
            enableNavigation();
        });

        socket.on('update_lobby', (lobby)=>{
            // update activeLobby if matches
            try{ appendDebugLine('update_lobby: ' + JSON.stringify({ id: lobby?.id, status: lobby?.status, players: Array.isArray(lobby?.players) ? lobby.players.length : 0 })); }catch(e){}
            if (!lobby) return;
            // if lobby object contains id
            if (activeLobby && lobby.id && activeLobby.id===lobby.id) {
                activeLobby = lobby;
            } else {
                // if not our lobby, but server sends update while in game view, swap
                activeLobby = lobby;
            }
            // if game finished — show end screen
            if (lobby.status === 'finished'){
                showLobby(lobby);
                // figure winner (lobby.winner may be 'X'/'O'/'draw')
                const winner = lobby.winner || null;
                let winnerName = '';
                let winnerAvatar = '';
                if (winner && winner !== 'draw'){
                    const pl = (lobby.players||[]).find(p=>p.symbol === winner);
                    if (pl){ winnerName = pl.name || 'Игрок'; winnerAvatar = pl.avatar || ''; }
                }
                showEndScreen({ winner: winner, name: winnerName, avatar: winnerAvatar });
                // ensure sidebar is visible again after game
                try{ document.querySelector('.app-sidebar').style.display = ''; }catch(e){}
            } else if (lobby.status==='playing' && !gameStarted) {
                gameStarted = true;
                try{
                    // when server signals game start, show preload then game
                    showPreload({ random: false });
                    setTimeout(()=>{ try{ showLobby(lobby); showView('game'); }catch(e){} }, 10100);
                }catch(e){ try{ appendDebugLine('update_lobby: showLobby/showView threw: '+(e&&e.message)); }catch(_){} }
            } else {
                showLobby(lobby);
            }
        });

        socket.on('update_lobbies', (data)=>{ renderLobbies(data); });

        function showLobby(lobby){
            activeLobby = lobby;
            try{ appendDebugLine('showLobby: received lobby ' + JSON.stringify({ id: lobby?.id, status: lobby?.status, playersType: Array.isArray(lobby?.players)? typeof (lobby.players[0]) : 'none' })); }catch(e){}
            // Defensive normalization: ensure players array, symbols, board and current_player are present so UI can render reliably
            try{
                if (!lobby || typeof lobby !== 'object') lobby = { id: lobby && lobby.id ? lobby.id : null };
                // normalize players to objects
                lobby.players = (lobby.players || []).map(p => (typeof p === 'string' ? { name: p } : (p || {})));
                // ensure two-player array for UI (do not mutate server authoritative state beyond UI safety)
                if (lobby.players.length < 2){
                    // pad with placeholders
                    while (lobby.players.length < 2) lobby.players.push({ name: 'Ожидание' });
                }
                // assign symbols if missing
                if (lobby.players[0] && !lobby.players[0].symbol) lobby.players[0].symbol = 'X';
                if (lobby.players[1] && !lobby.players[1].symbol) lobby.players[1].symbol = 'O';
                // ensure board exists
                if (!Array.isArray(lobby.board) || lobby.board.length !== 9) lobby.board = ['', '', '', '', '', '', '', '', ''];
                // ensure current_player set
                if (!lobby.current_player) lobby.current_player = lobby.current_player || (lobby.players[0] && lobby.players[0].symbol) || 'X';
                // write back to activeLobby as well
                activeLobby = lobby;
                appendDebugLine('showLobby: normalized lobby for UI (players:' + (lobby.players||[]).length + ', board:' + (Array.isArray(lobby.board)?lobby.board.length:0) + ', current:' + lobby.current_player + ')');
            }catch(err){ try{ appendDebugLine('showLobby: normalization error: '+(err&&err.message)); }catch(e){} }
            // players row
            const pr = document.getElementById('players-row'); pr.innerHTML = '';
            const playersArr = (lobby.players||[]).map(p => (typeof p === 'string' ? { name: p } : p));
            lobby.players = playersArr;
            playersArr.forEach(p=>{
                const d = document.createElement('div'); d.style.display='flex'; d.style.alignItems='center'; d.style.gap='8px';
                const imgWrap = document.createElement('div'); imgWrap.style.width='40px'; imgWrap.style.height='40px'; imgWrap.style.borderRadius='8px'; imgWrap.style.background='var(--glass)'; imgWrap.style.display='flex'; imgWrap.style.alignItems='center'; imgWrap.style.justifyContent='center'; imgWrap.style.fontWeight='600';
                if (p.avatar){ const img = document.createElement('img'); img.src = p.avatar; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover'; img.style.borderRadius='8px'; imgWrap.appendChild(img); }
                else { imgWrap.textContent = escapeHtml((p.name||'Игрок').slice(0,1)); }
                const infoWrap = document.createElement('div'); infoWrap.innerHTML = `<div style='font-weight:600'>${escapeHtml(p.name||'Игрок')}</div><div style='color:var(--muted);font-size:12px'>${escapeHtml(p.symbol||'')}</div>`;
                d.appendChild(imgWrap); d.appendChild(infoWrap);
                pr.appendChild(d);
            });

            const status = document.getElementById('game-status');
            if (lobby.status === 'playing'){
                // determine current player symbol and name
                const curSym = lobby.current_player || 'X';
                const cur = (lobby.players || []).find(pl => (pl.symbol||'') === curSym) || null;
                const curName = cur ? cur.name : 'Игрок';
                status.textContent = `Сейчас ход: ${curSym} — ${curName}`;
            } else {
                status.textContent = 'Ожидание игроков...';
            }

            // render board if present
            if (lobby.board) renderBoard(lobby);

            // ensure unload handler registration reflects current game state
            try{ _maybeRegisterUnload(); }catch(e){ try{ appendDebugLine('showLobby: _maybeRegisterUnload threw: '+(e&&e.message)); }catch(_){} }
        }

        // Board rendering for tictactoe
        function renderBoard(lobby){
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            const board = lobby.board || ['', '', '', '', '', '', '', '', ''];
            for (let i=0;i<9;i++){
                const cell = document.createElement('button');
                cell.className = 'ttt-cell';
                cell.dataset.pos = i;
                // use CSS aspect-ratio for square cells, set visual styles
                cell.style.borderRadius = '12px';
                cell.style.display = 'flex';
                cell.style.alignItems = 'center';
                cell.style.justifyContent = 'center';
                // slightly smaller icons for mobile and desktop
                cell.style.fontSize = window.innerWidth < 420 ? '18px' : '22px';
                cell.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.02), transparent)';
                cell.style.border = '1px solid rgba(255,255,255,0.04)';
                // render icons for X/O
                cell.innerHTML = '';
                if (board[i] === 'X'){
                    const wrap = document.createElement('div'); wrap.className='icon-x'; wrap.style.width='60%'; wrap.style.height='60%'; wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.justifyContent='center';
                    wrap.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width:100%;height:100%;display:block" preserveAspectRatio="xMidYMid meet"><line x1="4" y1="4" x2="20" y2="20" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"/></svg>`;
                    // add second line separately to avoid duplicate stroke overlap issues on some engines
                    const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
                    // fallback: append as innerHTML with both lines
                    wrap.innerHTML = `<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\" style=\"width:100%;height:100%;display:block\" preserveAspectRatio=\"xMidYMid meet\"><line x1=\"4\" y1=\"4\" x2=\"20\" y2=\"20\" stroke=\"currentColor\" stroke-width=\"2.2\" stroke-linecap=\"round\"/><line x1=\"20\" y1=\"4\" x2=\"4\" y2=\"20\" stroke=\"currentColor\" stroke-width=\"2.2\" stroke-linecap=\"round\"/></svg>`;
                    cell.appendChild(wrap);
                } else if (board[i] === 'O'){
                    const wrap = document.createElement('div'); wrap.className='icon-o'; wrap.style.width='60%'; wrap.style.height='60%'; wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.justifyContent='center';
                    wrap.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width:100%;height:100%;display:block" preserveAspectRatio="xMidYMid meet"><circle cx="12" cy="12" r="8" stroke="currentColor" stroke-width="2.2" fill="none"/></svg>`;
                    cell.appendChild(wrap);
                } else {
                    cell.textContent = '';
                }
                if (!board[i] && lobby.status==='playing'){
                    // allow click only if this client is the current player
                    const mySid = socket.id;
                    const curSym = lobby.current_player || 'X';
                    const amICurrent = (lobby.players || []).some(p => p.sid === mySid && p.symbol === curSym);
                    if (amICurrent){
                        cell.addEventListener('click', ()=>{
                            if (!activeLobby || !activeLobby.id) return;
                            socket.emit('make_move', { lobby_id: activeLobby.id, position: i });
                        });
                    }
                }
                boardEl.appendChild(cell);
            }
        }

        // leave / forfeit
        document.getElementById('btn-leave').addEventListener('click', ()=>{
            try{
                // if game already started, ask for confirmation to forfeit
                if (activeLobby && activeLobby.status === 'playing') {
                    const ok = window.confirm('Игра в процессе. Вы уверены, что хотите покинуть и сдаться?');
                    if (!ok) return;
                    try{ socket.emit('make_move',{ lobby_id: activeLobby.id, position: -1, forfeit: true }); }catch(e){ appendDebugLine('leave: emit forfeit failed: '+(e&&e.message)); }
                    activeLobby = null;
                    showView('home');
                    try{ socket.emit('get_lobbies'); }catch(e){}
                    return;
                }
                activeLobby=null; showView('home'); try{ socket.emit('get_lobbies'); }catch(e){}
            }catch(e){ console.warn('btn-leave handler error', e); }
        });
        document.getElementById('btn-forfeit').addEventListener('click', ()=>{
            try{
                if (activeLobby && activeLobby.id){
                    try{ socket.emit('make_move',{ lobby_id: activeLobby.id, position: -1, forfeit:true }); appendDebugLine('forfeit: emitted for lobby ' + activeLobby.id); }catch(e){ appendDebugLine('forfeit emit failed: '+(e&&e.message)); }
                    // navigate back to home after sending forfeit
                    activeLobby = null;
                    showView('home');
                    try{ socket.emit('get_lobbies'); }catch(e){}
                } else {
                    appendDebugLine('forfeit clicked but no activeLobby');
                }
            }catch(e){ console.warn('btn-forfeit handler error', e); }
        });

        // Reload/close protection: when in an active playing game, intercept refresh/close
        function _showReloadConfirm(){
            document.getElementById('reload-confirm-modal').style.display = 'flex';
        }
        function _hideReloadConfirm(){
            document.getElementById('reload-confirm-modal').style.display = 'none';
        }

        document.getElementById('reload-cancel').addEventListener('click', ()=>{ _hideReloadConfirm(); });
        document.getElementById('reload-confirm').addEventListener('click', ()=>{
            // if in game, send forfeit to end game, then reload
            try{
                if (activeLobby && activeLobby.id){
                    socket.emit('make_move', { lobby_id: activeLobby.id, position: -1, forfeit: true });
                }
            }catch(e){}
            _hideReloadConfirm();
            // small delay to allow message to send
            setTimeout(()=>{ location.reload(); }, 300);
        });

        // beforeunload handler
        function _onBeforeUnload(e){
            if (activeLobby && activeLobby.status === 'playing'){
                // show native confirmation when possible
                const msg = 'Вы участвуете в игре. Перезагрузка завершит игру. Уверены?';
                (e || window.event).returnValue = msg; // Gecko + IE
                return msg; // Webkit, Chrome
            }
            return undefined;
        }

        // keydown intercept for F5 / Ctrl+R to show modal instead of immediate reload
        window.addEventListener('keydown', (ev)=>{
            const isRefresh = (ev.key === 'F5') || ((ev.ctrlKey || ev.metaKey) && ev.key === 'r');
            if (!isRefresh) return;
            if (activeLobby && activeLobby.status === 'playing'){
                ev.preventDefault();
                _showReloadConfirm();
            }
        }, { capture: true });

        // register/unregister beforeunload depending on game state
        function _maybeRegisterUnload(){
            if (activeLobby && activeLobby.status === 'playing') window.addEventListener('beforeunload', _onBeforeUnload);
            else window.removeEventListener('beforeunload', _onBeforeUnload);
        }

        // (previously attempted to wrap showLobby; wrapper removed to avoid recursion)

        // display end-of-game modal with winner info and return-home action
        function showEndScreen(payload){
            gameStarted = false;
            try{
                appendDebugLine('showEndScreen: payload=' + JSON.stringify(payload));
                const modal = document.getElementById('end-modal');
                const avatarEl = document.getElementById('winner-avatar');
                const nameEl = document.getElementById('winner-name');
                const subEl = document.getElementById('winner-sub');
                const emojiEl = document.getElementById('winner-emoji');
                const btn = document.getElementById('btn-return-home');

                // payload may be (lobby) or { winner, name, avatar }
                let winnerName = payload && payload.name ? payload.name : null;
                let winnerAvatar = payload && payload.avatar ? payload.avatar : null;
                if ((!winnerName || !winnerAvatar) && payload && payload.players){
                    // try to infer from lobby players
                    const w = payload.players.find(p => p.is_winner || (payload.winner && (p.symbol === payload.winner || p.user_id == payload.winner)));
                    if (w){ winnerName = winnerName || w.name; winnerAvatar = winnerAvatar || w.avatar; }
                }

                // populate
                if (avatarEl){ avatarEl.innerHTML = ''; if (winnerAvatar){ const img = document.createElement('img'); img.src = winnerAvatar; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover'; avatarEl.appendChild(img); } else { avatarEl.textContent = (winnerName||'').slice(0,1).toUpperCase(); } }
                if (nameEl) nameEl.textContent = winnerName || 'Ничья';
                if (subEl) subEl.textContent = winnerName ? 'Победитель' : 'Ничья';

                // render mini board if available
                try{ renderEndMini(payload && payload.board ? payload.board : null); }catch(e){ appendDebugLine('renderEndMini threw: '+(e&&e.message)); }

                // animate modal in (CSS already defines popIn on .end-card)
                modal.style.display = 'flex';
                // ensure TGS animation plays when modal becomes visible
                try{
                    appendDebugLine && appendDebugLine('showEndScreen: attempting to play tgs animation (with retries)');
                    const anim = window.__tgs_trophy_anim;
                    if (anim && typeof anim.play === 'function'){
                        try{ anim.loop = true; }catch(e){}
                        try{ if (typeof anim.setSpeed === 'function') anim.setSpeed(1); }catch(e){}
                        // try immediate play and a couple of retries with short delays
                        try{ anim.play(); appendDebugLine && appendDebugLine('showEndScreen: tgs play() immediate called'); }catch(e){ appendDebugLine && appendDebugLine('showEndScreen: immediate play threw: '+(e&&e.message)); }
                        setTimeout(()=>{ try{ anim.play(); appendDebugLine && appendDebugLine('showEndScreen: tgs play() retry +50ms'); }catch(e){ appendDebugLine && appendDebugLine('showEndScreen: retry +50ms threw: '+(e&&e.message)); } }, 50);
                        setTimeout(()=>{ try{ anim.play(); appendDebugLine && appendDebugLine('showEndScreen: tgs play() retry +300ms'); }catch(e){ appendDebugLine && appendDebugLine('showEndScreen: retry +300ms threw: '+(e&&e.message)); } }, 300);
                    } else {
                        appendDebugLine && appendDebugLine('showEndScreen: no tgs animation instance available');
                    }
                }catch(e){ appendDebugLine && appendDebugLine('showEndScreen: tgs play attempt error: '+(e&&e.message)); }

                // wire button
                if (btn){ btn.onclick = function(){ appendDebugLine('end-modal: return home clicked'); modal.style.display='none'; activeLobby = null; showView('home'); try{ socket.emit('get_lobbies'); }catch(e){} }; }
            }catch(e){ console.error('showEndScreen error', e); appendDebugLine('showEndScreen error: '+(e&&e.message)); }
        }

        // render small 3x3 mini-board inside end modal. board is array[9] or null
        function renderEndMini(board){
            const root = document.getElementById('end-mini');
            if (!root) return;
            root.innerHTML = '';
            // fallback board pattern: top-left O, bottom-left O, bottom-right X
            const fallback = ['', '', '', '', '', '', '', '', ''];
            fallback[0] = 'O'; fallback[6] = 'O'; fallback[8] = 'X';
            const b = Array.isArray(board) && board.length===9 ? board : fallback;
            for (let i=0;i<9;i++){
                const c = document.createElement('div'); c.className='mini-cell';
                const v = b[i];
                if (v === 'X'){
                    const wrap = document.createElement('div'); wrap.className='icon-x'; wrap.style.width='80%'; wrap.style.height='80%'; wrap.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width:100%;height:100%;display:block"><line x1="4" y1="4" x2="20" y2="20" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><line x1="20" y1="4" x2="4" y2="20" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>`;
                    c.appendChild(wrap);
                } else if (v === 'O'){
                    const wrap = document.createElement('div'); wrap.className='icon-o'; wrap.style.width='80%'; wrap.style.height='80%'; wrap.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width:100%;height:100%;display:block"><circle cx="12" cy="12" r="8" stroke="currentColor" stroke-width="2" fill="none"/></svg>`;
                    c.appendChild(wrap);
                }
                root.appendChild(c);
            }
        }

        // safe html
        function escapeHtml(s){ return String(s||'').replace(/[&<>\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

        // After initial load show home
        showView('home');

        // --- Modern WebAudio sound engine (layered synth + noise) ---
        const SoundEngine = (function(){
            let ac = null;
            let muted = false;

            function init(){ if (ac) return; ac = new (window.AudioContext || window.webkitAudioContext)(); }
            function resume(){ if (!ac) init(); if (ac.state === 'suspended') return ac.resume(); return Promise.resolve(); }

            // removed complex noise generator to avoid 8-bit artifacts; use pure tones only

            // Percussive tactile click: softened transient using sine body + filtered click + shaped noise
            function playClick(opts){
                if (!ac) init();
                const now = ac.currentTime + (opts.delay || 0);

                // body oscillator (low) for 'thud' — use sine for smoothness
                const body = ac.createOscillator(); body.type = opts.bodyType || 'sine';
                body.frequency.setValueAtTime(opts.bodyFreq || 160, now);
                const gBody = ac.createGain(); gBody.gain.setValueAtTime(0.0001, now);
                gBody.gain.linearRampToValueAtTime(opts.bodyGain || 0.10, now + 0.002);
                gBody.gain.exponentialRampToValueAtTime(0.0001, now + (opts.bodyDur || 0.12));
                body.connect(gBody);

                // click oscillator (high transient) — use sine and gentle sweep, then lowpass to remove digital harshness
                const click = ac.createOscillator(); click.type = opts.clickType || 'sine';
                click.frequency.setValueAtTime(opts.clickFreq || 2200, now);
                // gentler pitch sweep for character without chiptune artifacts
                click.frequency.linearRampToValueAtTime((opts.clickFreq || 2200) * 0.85, now + 0.035);
                const gClick = ac.createGain(); gClick.gain.setValueAtTime(0.0001, now);
                gClick.gain.linearRampToValueAtTime(opts.clickGain || 0.08, now + 0.003);
                gClick.gain.exponentialRampToValueAtTime(0.0001, now + (opts.clickDur || 0.05));
                // lowpass to soften the top end (removes '8-bit' brightness)
                const clickLP = ac.createBiquadFilter(); clickLP.type = 'lowpass'; clickLP.frequency.setValueAtTime(opts.clickLP || 3800, now);
                click.connect(clickLP);
                clickLP.connect(gClick);

                // removed noise path; rely on body + filtered click for tactile feel

                // master gain for click
                const master = ac.createGain(); master.gain.setValueAtTime(opts.masterGain || 1.0, now);

                // routing
                gBody.connect(master); gClick.connect(master);
                master.connect(ac.destination);

                // start/stop
                body.start(now); body.stop(now + (opts.bodyDur || 0.12) + 0.02);
                click.start(now); click.stop(now + (opts.clickDur || 0.05) + 0.01);
                // no noise to start
            }

            // small melodic ping for confirmations — keep smooth sine and slightly lower amplitude
            function playPing(freq, dur, amp, delay){
                if (!ac) init();
                const now = ac.currentTime + (delay || 0);
                const o = ac.createOscillator(); o.type = 'sine'; o.frequency.setValueAtTime(freq, now);
                const g = ac.createGain(); g.gain.setValueAtTime(0.0001, now);
                g.gain.linearRampToValueAtTime((amp || 0.09), now + 0.006);
                g.gain.exponentialRampToValueAtTime(0.0001, now + (dur || 0.16));
                // subtle highcut so pings aren't too bright
                const lp = ac.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.setValueAtTime(5200, now);
                o.connect(g); g.connect(lp); lp.connect(ac.destination);
                o.start(now); o.stop(now + (dur || 0.16) + 0.02);
            }

            function uiClick(kind){ // very simple UI clicks: short sine click
                resume().then(()=>{
                    if (!ac) return;
                    const now = ac.currentTime;
                    const o = ac.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(kind==='primary' ? 800 : 600, now);
                    const g = ac.createGain(); g.gain.setValueAtTime(0.0001, now);
                    g.gain.linearRampToValueAtTime(kind==='primary' ? 0.12 : 0.08, now + 0.006);
                    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.09);
                    o.connect(g); g.connect(ac.destination);
                    o.start(now); o.stop(now + 0.09);
                }).catch(()=>{});
            }

            // upbeat match found sound: short arpeggio of pings
            function matchFound(){
                resume().then(()=>{
                    try{
                        // three ascending pings
                        playPing(880, 0.12, 0.10, 0);
                        playPing(1100, 0.12, 0.08, 0.06);
                        playPing(1400, 0.12, 0.07, 0.13);
                        // a soft thud for body
                        playClick({ bodyFreq: 120, bodyGain: 0.08, bodyDur: 0.12, clickGain: 0.04, clickFreq: 1200 });
                    }catch(e){ }
                }).catch(()=>{});
            }

            function select(){ resume().then(()=>{ uiClick('soft'); }); }
            function modalOpen(){ resume().then(()=>{ uiClick('primary'); }); }
            function create(){ resume().then(()=>{ uiClick('primary'); }); }
            function lobbyCreated(){ resume().then(()=>{ uiClick('primary'); setTimeout(()=>{ uiClick('soft'); }, 120); }); }

            // modern presets
            function setMuted(v){ muted = !!v; }
            function isMuted(){ return !!muted; }

            // no UI mute button by default (removed per request)
            // init muted default false
            (function(){ muted = false; })();

            // no background music implementation — feature removed
            // keep the public API surface for sound effects and confirmations
            return { init, resume, uiClick, select, modalOpen, create, lobbyCreated, matchFound, setMuted, isMuted };
        })();

        // --- Game selection: mobile-friendly selection + floating Play button ---
        (function(){
            const isMobile = window.matchMedia && window.matchMedia('(max-width: 720px)').matches;
            // allow floating Play button behaviour on desktop as well

            // create floating play button if not present
        playButton = document.querySelector('.play-button');
            if (!playButton) {
                playButton = document.createElement('button');
                playButton.className = 'play-button';
                playButton.setAttribute('aria-hidden', 'true');
                playButton.textContent = 'Играть';
                document.body.appendChild(playButton);
            }
            // make floating button a bit wider on desktop and slightly higher
            if (!isMobile){ playButton.style.padding = '12px 32px'; playButton.style.bottom = '120px'; }

            // hide global floating Play button completely (we'll use per-card play buttons)
            try{ if (playButton) playButton.style.display = 'none'; }catch(e){}

            let selected = null;

            function updateListeners(){
                const cards = document.querySelectorAll('.game-selection .game-card');
                cards.forEach(card => {
                    card.setAttribute('role','button');
                    card.setAttribute('tabindex','0');
                    card.onclick = null;
                    card.addEventListener('click', (e)=>{
                        e.stopPropagation();
                        // while searching, ignore card clicks to avoid clearing selection / hiding cancel
                        if (searching) return;
                        // do not allow selecting disabled/coming-soon cards
                        if (card.getAttribute('aria-disabled') === 'true' || card.querySelector('.disabled')) return;

                        if (selected === card) {
                            card.classList.remove('selected');
                            card.setAttribute('aria-selected','false');
                            selected = null;
                            // hide any per-card play button
                            const pbtn = card.querySelector('.card-play-btn'); if (pbtn) pbtn.style.display='none';
                        } else {
                            if (selected) { selected.classList.remove('selected'); selected.setAttribute('aria-selected','false'); }
                            selected = card;
                            card.classList.add('selected');
                            card.setAttribute('aria-selected','true');
                            // force focus and repaint so visual border appears immediately
                            try{ card.focus(); card.getBoundingClientRect(); }catch(e){}
                            // show animated play button
                            // create or show per-card play button inside card using unified factory
                            let pbtn = createCardPlayButton(card);
                            if (pbtn) pbtn.style.display = 'block';
                            playButton.classList.remove('visible');
                            playButton.setAttribute('aria-hidden','true');
                            // ensure audio context is allowed by user gesture and play a select sound
                            try{ SoundEngine.init(); SoundEngine.select(); }catch(e){}
                        }
                    });
                    card.addEventListener('keydown', (ev)=>{
                        if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); card.click(); }
                    });
                            // on mobile ensure play button exists (but keep it hidden until selection)
                    try{
                        const isMobileNow = window.matchMedia && window.matchMedia('(max-width:720px)').matches;
                        if (isMobileNow){
                            // ensure factory exists but do not show by default on mobile
                            createCardPlayButton(card);
                        }
                    }catch(e){}
                });
            }

            updateListeners();

            // helper: ensure each card has no visible inline play buttons by default (we'll create them dynamically)
            document.querySelectorAll('.game-selection .game-card .card-play-btn').forEach(b=>b.style.display='none');

            // helper to create or return per-card play button with unified handler
            function createCardPlayButton(card){
                if (!card) return null;
                const game = (card.dataset.game || '').toLowerCase();
                // skip not-ready games
                if (game === 'memory' || game === 'quiz') return null;
                let pbtn = card.querySelector('.card-play-btn');
                if (!pbtn){
                    pbtn = document.createElement('button');
                    // ensure this is a real button so it receives focus/click properly
                    pbtn.type = 'button';
                    pbtn.className = 'menu-btn card-play-btn primary';
                    pbtn.textContent = 'Играть';
                    pbtn.style.alignSelf = 'stretch'; pbtn.style.marginTop = '6px';
                    // make sure pointer events are enabled and button is on top of overlays if needed
                    pbtn.style.pointerEvents = 'auto';
                    pbtn.style.zIndex = '2000';
                    pbtn.dataset.searching = '0';

                    // defensive: ensure not disabled
                    pbtn.disabled = false;

                    // pointerdown logging helps diagnose platforms where click doesn't fire
                    pbtn.addEventListener('pointerdown', function(ev){
                        // don't let parent card selection steal the event
                        ev.stopPropagation();
                        try{ if (typeof appendDebugLine === 'function') appendDebugLine('pointerdown on card play'); }catch(e){}
                    }, { passive: true });

                    // unified click handler: start or cancel depending on state
                    pbtn.addEventListener('click', function(ev){
                        ev.stopPropagation();
                        try{
                            // defensive reset in case some flow left this disabled
                            pbtn.disabled = false;
                            pbtn.style.pointerEvents = 'auto';

                            const isSearching = pbtn.dataset.searching === '1';
                            const gameName = card.dataset.game || card.querySelector('h3')?.textContent || '';
                            try{ if (typeof appendDebugLine === 'function') appendDebugLine('card play click: ' + gameName + ' searching=' + isSearching); }catch(e){}

                            if (!currentUser || !currentUser.user_id){ openAuthModal(); return; }
                            if (!isSearching){
                                // start
                                lastSearchStart = Date.now(); lastSearchGame = gameName;
                                // prefer create_lobby for reliability; keep quick_match for backward compat
                                try{
                                    socket.emit('quick_match', { player_name: currentUser?.name, player_avatar: currentUser?.avatar, user_id: currentUser?.user_id, game: gameName });
                                }catch(e){ console.warn('emit quick_match failed', e); }

                                pbtn.dataset.searching = '1'; pbtn.textContent = 'Отменить'; pbtn.classList.remove('primary'); pbtn.classList.add('danger');
                                showSearchIndicator({ game: gameName, player: { name: currentUser?.name, avatar: currentUser?.avatar }, foundCount: 1, originCard: card });
                            } else {
                                // cancel
                                try{ socket.emit('cancel_quick_match', {}); }catch(e){}
                                pbtn.dataset.searching = '0'; pbtn.textContent = 'Играть'; pbtn.classList.remove('danger'); pbtn.classList.add('primary');
                                hideSearchIndicator();
                            }
                        }catch(er){ console.warn('card play handler err', er); }
                    });
                    card.appendChild(pbtn);
                }
                return pbtn;
            }

                // Delegated click handler as a safety net: ensure cancel works even if per-button handlers
                // were not attached due to race conditions. If searching is active and a card-play-btn
                // is clicked, emit cancel_quick_match and reset UI.
                document.addEventListener('click', function(ev){
                    try{
                        const btn = ev.target.closest && ev.target.closest('.card-play-btn');
                        if (!btn) return;
                        // if global searching active and this button indicates searching -> cancel
                        if (searching && btn.dataset && btn.dataset.searching === '1'){
                            ev.stopPropagation(); ev.preventDefault();
                            try{ socket.emit('cancel_quick_match', {}); }catch(e){}
                            try{ hideSearchIndicator(); }catch(e){}
                            // reset all per-card buttons UI
                            try{ document.querySelectorAll('.card-play-btn').forEach(b=>{ b.dataset.searching='0'; b.textContent='Играть'; b.classList.remove('danger'); b.classList.add('primary'); b.style.background=''; b.style.color=''; b.style.borderColor=''; b.style.display = b.closest('.game-card') && b.closest('.game-card').classList.contains('selected') ? 'block' : 'none'; }); }catch(e){}
                        }
                    }catch(e){}
                }, { capture: true });

            // start search for card (direct implementation without recursion)
            function startCardSearch(card){
                if (!card) return;

                const gameName = card.dataset.game || card.querySelector('h3')?.textContent || '';

                // skip not-ready games
                if (gameName === 'memory' || gameName === 'quiz') return;

                // check if user is authenticated
                if (!currentUser || !currentUser.user_id) {
                    console.log('User not authenticated, showing auth modal');
                    openAuthModal();
                    return;
                }

                // start search directly without creating button
                lastSearchStart = Date.now();
                lastSearchGame = gameName;

                try {
                    console.log('User authenticated, starting game search for:', gameName);
                    console.log('Socket connected:', !!(socket && socket.connected));
                    console.log('User authenticated:', !!currentUser?.user_id);

                    if (!socket || !socket.connected) {
                        alert('Нет подключения к серверу. Попробуйте перезагрузить страницу.');
                        return;
                    }

                    if (!currentUser?.user_id) {
                        alert('Необходимо авторизоваться для начала игры');
                        openAuthModal();
                        return;
                    }

                    // Use create_lobby for reliability
                    const lobbyData = {
                        name: `${currentUser.name || 'Игрок'}'s ${gameName} game`,
                        game: gameName,
                        player_name: currentUser.name,
                        player_avatar: currentUser.avatar || '',
                        user_id: currentUser.user_id,
                        hidden: true // Create hidden lobby for quick match
                    };

                    try{ if (typeof appendDebugLine === 'function') appendDebugLine('about to emit quick_match for ' + gameName); }catch(e){}
                    // Mark button state (if present) to searching so UI updates to 'Отменить'
                    try{
                        const pbtn = card.querySelector('.card-play-btn');
                        if (pbtn) { pbtn.dataset.searching = '1'; pbtn.textContent = 'Отменить'; pbtn.classList.remove('primary'); pbtn.classList.add('danger'); }
                    }catch(e){}
                    // Emit quick_match for a fast matchmaking flow (server will create hidden lobby and match)
                    try{ socket.emit('quick_match', { player_name: currentUser?.name, player_avatar: currentUser?.avatar, user_id: currentUser?.user_id, game: gameName }); }catch(e){ console.warn('emit quick_match failed', e); }

                    // show search indicator
                    try { showSearchIndicator({ game: gameName, player: { name: currentUser?.name, avatar: currentUser?.avatar }, foundCount: 1, originCard: card }); } catch(e) { console.warn('Failed to show search indicator:', e); }

                } catch (error) {
                    console.error('Error creating lobby:', error);
                    alert('Ошибка при создании лобби: ' + (error && error.message ? error.message : String(error)));
                }
            }

            // diagnostic hooks removed in production — logging kept minimal

            // hide selection when tapping outside — but DO NOT clear selection while searching for opponent
            document.addEventListener('click', (ev)=>{
                // if searching, ignore outside clicks (keep selection and cancel only via playButton)
                if (searching) {
                    // allow clicks on playButton (it will handle cancel) and on modals
                    if (ev.target.closest('.play-button') || ev.target.closest('.game-modal')) return;
                    // also ignore clicks inside the game selection area or on cards themselves
                    if (ev.target.closest('.game-selection') || ev.target.closest('.game-card')) return;
                    // otherwise ignore outside clicks while searching
                    return;
                }
                // if clicked outside both card and modal and not on playButton — clear selection
                if (!ev.target.closest('.game-card') && !ev.target.closest('.play-button') && !ev.target.closest('.game-modal')){
                    if (selected) { selected.classList.remove('selected'); selected.setAttribute('aria-selected','false'); selected = null; }
                    playButton.classList.remove('visible');
                    playButton.setAttribute('aria-hidden','true');
                }
            });

            // clicking floating Play toggles quick-match / cancel while respecting searching state
            playButton.addEventListener('click', (ev)=>{
                ev.stopPropagation();
                // if not selected and not searching, nothing to do
                if (!selected && !searching) return;
                if (!currentUser || !currentUser.user_id) { openAuthModal(); return; }
                if (searching) {
                    try{ socket.emit('cancel_quick_match', {}); }catch(e){}
                    hideSearchIndicator();
                    return;
                }
                // immediate emit: start quick match now and show indicator
                const gameName = selected ? (selected.dataset.game || (selected.querySelector('h3')?.textContent || '')) : null;
                // reset any previous confirm modal state before starting a fresh search
                try{ document.getElementById('confirm-modal').style.display = 'none'; }catch(e){}
                try{ if (confirmCountdown){ clearInterval(confirmCountdown); confirmCountdown = null; } }catch(e){}
                try{ document.getElementById('confirm-waiting').style.display = 'none'; document.getElementById('confirm-buttons').style.display = 'flex'; }catch(e){}
                // mark search start timestamp so we ignore stale server events
                lastSearchStart = Date.now(); lastSearchGame = gameName;
                socket.emit('quick_match', { player_name: currentUser?.name, player_avatar: currentUser?.avatar, user_id: currentUser?.user_id, game: gameName });
                try{ showSearchIndicator({ game: gameName, player: { name: currentUser?.name, avatar: currentUser?.avatar }, foundCount: 1 }); }catch(e){}
                try{ SoundEngine.modalOpen(); }catch(e){}
            });

                // ensure floating play button and search indicator are positioned correctly on desktop
                function positionFloatingControls(){
                    try{
                        // target the game-selection column (where cards are) so the Play button centers over the list
                        const target = document.querySelector('.game-selection') || document.querySelector('.app-main') || document.querySelector('.app-container');
                        const search = document.getElementById('search-indicator');
                        if (!playButton || !target) return;
                        const isMobileNow = window.matchMedia && window.matchMedia('(max-width: 720px)').matches;
                        if (!isMobileNow){
                            const rect = target.getBoundingClientRect();
                            const centerX = rect.left + rect.width/2;
                            // horizontally center over game-selection, but keep vertical position fixed near viewport bottom
                            playButton.style.left = centerX + 'px';
                            playButton.style.transform = 'translateX(-50%) translateY(0) scale(1)';
                            const desktopBottom = 86; // fixed distance from viewport bottom
                            playButton.style.bottom = desktopBottom + 'px';

                            // position search-indicator above the Play button to avoid overlap
                            if (search) {
                                search.style.left = centerX + 'px';
                                search.style.transform = 'translateX(-50%)';
                                search.style.bottom = (desktopBottom + playButton.offsetHeight + 18) + 'px';
                            }
                        } else {
                            // mobile fallback: center in viewport and place higher to avoid bottom nav
                            playButton.style.left = '50%';
                            playButton.style.transform = 'translateX(-50%) translateY(0) scale(.98)';
                            const mobileBottom = 120;
                            playButton.style.bottom = mobileBottom + 'px';
                            if (search) {
                                search.style.left = '50%';
                                search.style.transform = 'translateX(-50%)';
                                // ensure search indicator is not too close to Play button on mobile
                                const searchMin = mobileBottom + playButton.offsetHeight + 22;
                                search.style.bottom = Math.max(searchMin, 160) + 'px';
                            }
                        }
                    }catch(e){ console.warn('positionFloatingControls err', e); }
                }
                // run initially and on resize/orientation change
                positionFloatingControls();
                window.addEventListener('resize', ()=>{ positionFloatingControls(); });

            // Modal: show selected game and allow create lobby
            function openGameModal(card){
                // if modal exists, remove
                const existing = document.querySelector('.game-modal');
                if (existing) existing.remove();

                const game = card.dataset.game || '';
                const title = card.querySelector('h3')?.textContent || game;

                const overlay = document.createElement('div');
                overlay.className = 'game-modal';
                overlay.style.position = 'fixed';
                overlay.style.inset = '0';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.background = 'rgba(2,6,23,0.6)';
                overlay.style.zIndex = 1200;

                const box = document.createElement('div');
                box.style.width = '92%'; box.style.maxWidth = '420px'; box.style.background = 'var(--card)'; box.style.border = '1px solid var(--glass)'; box.style.borderRadius='12px'; box.style.padding='18px'; box.style.boxShadow='0 14px 40px rgba(2,6,23,0.6)';

                box.innerHTML = `<h3 style="margin:0 0 8px 0">${escapeHtml(title)}</h3><p style="margin:0 0 12px 0;color:var(--muted)">Создать лобби и ждать противника. Название лобби можно изменить.</p>`;
                const input = document.createElement('input');
                input.value = `${currentUser?.name || 'Игрок'}'s lobby`;
                input.style.width='100%'; input.style.padding='10px'; input.style.borderRadius='10px'; input.style.border='1px solid var(--glass)'; input.style.background='transparent'; input.style.color='var(--text)'; input.style.marginBottom='12px';

                const row = document.createElement('div'); row.style.display='flex'; row.style.gap='8px'; row.style.justifyContent='flex-end';
                const btnCreate = document.createElement('button'); btnCreate.className='menu-btn primary'; btnCreate.textContent='Создать лобби';
                const btnClose = document.createElement('button'); btnClose.className='menu-btn'; btnClose.textContent='Отмена';
                row.appendChild(btnClose); row.appendChild(btnCreate);

                box.appendChild(input); box.appendChild(row);
                overlay.appendChild(box);
                document.body.appendChild(overlay);

                // prevent outside clicks from closing modal unintentionally
                overlay.addEventListener('click', (e)=>{ if (e.target === overlay){ /* click outside closes modal */ overlay.remove(); } });
                btnClose.addEventListener('click', ()=>{ overlay.remove(); });

                btnCreate.addEventListener('click', ()=>{
                    const name = input.value || `${currentUser?.name || 'Игрок'}'s lobby`;
                    // emit create_lobby — socket handler on server will send 'lobby_created' and client will switch to game view
                    socket.emit('create_lobby', { name, player_name: currentUser?.name || 'Игрок', player_avatar: currentUser?.avatar || '', user_id: currentUser?.user_id });
                    try{ SoundEngine.create(); }catch(e){}
                    // show waiting state in modal
                    box.innerHTML = `<h3 style="margin:0 0 8px 0">${escapeHtml(title)}</h3><p style="margin:0 0 12px 0;color:var(--muted)">Лобби создаётся. Ожидание игроков...</p><div style="display:flex;gap:8px;justify-content:flex-end;"><button class="menu-btn">Закрыть</button></div>`;
                    const closeNow = box.querySelector('.menu-btn');
                    closeNow.addEventListener('click', ()=>{ overlay.remove(); });
                });
            }

            // pre-search feature removed: quick_match is emitted immediately on Play
        })();

        // Delegated UI sound handler — covers buttons, menu-btn, links, input interactions
        (function(){
            document.addEventListener('click', (ev)=>{
                const btn = ev.target.closest('button, [role=button], a, input, select, textarea');
                if (!btn) return;
                // ignore decorative controls
                if (btn.disabled) return;
                // decide kind
                let kind = 'neutral';
                if (btn.classList && btn.classList.contains('primary')) kind = 'primary';
                else if (btn.classList && btn.classList.contains('danger')) kind = 'destructive';
                else if (btn.classList && btn.classList.contains('menu-btn')) kind = 'soft';
                try{ SoundEngine.uiClick(kind); }catch(e){}
            }, { capture: true });

            // also keyboard activation (Enter/Space)
            document.addEventListener('keydown', (ev)=>{
                if (ev.key !== 'Enter' && ev.key !== ' ') return;
                const el = document.activeElement;
                if (!el) return;
                const interactive = el.matches && el.matches('button, [role=button], a, input[type=checkbox], input[type=radio]');
                if (!interactive) return;
                let kind = 'neutral';
                if (el.classList && el.classList.contains('primary')) kind = 'primary';
                try{ SoundEngine.uiClick(kind); }catch(e){}
            });
        })();

        // --- Disable selection/copy globally except on allowed controls ---
        (function(){
            function isSelectable(el){
                if (!el) return false;
                if (el.closest && (el.closest('input,textarea,[contenteditable=true]') || el.closest('#auth-modal') || el.closest('.allow-select'))) return true;
                if (el.matches && (el.matches('input,textarea,[contenteditable=true]') || el.classList && el.classList.contains('allow-select'))) return true;
                return false;
            }

            ['copy','cut','selectstart'].forEach(ev => {
                document.addEventListener(ev, function(e){
                    try{
                        if (!isSelectable(e.target)) e.preventDefault();
                    }catch(err){ }
                }, { capture: true });
            });

            // optionally block context menu except for allowed targets
            document.addEventListener('contextmenu', function(e){ try{ if (!isSelectable(e.target) && !e.target.closest('.menu-btn')) e.preventDefault(); }catch(err){} }, { capture: true });
        })();
    </script>
    <!-- In-page debug panel (visible in Mini App when devs need to see socket events) -->
    <div id="debug-panel" class="allow-select" style="position:fixed;right:12px;bottom:12px;width:320px;max-height:50vh;overflow:auto;background:rgba(2,6,23,0.9);border:1px solid rgba(255,255,255,0.04);border-radius:10px;padding:8px;font-size:12px;color:var(--muted);z-index:1400;display:none">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
            <strong style="color:var(--text);font-weight:700">Debug</strong>
            <div style="display:flex;gap:6px;align-items:center">
                <button id="debug-copy" class="menu-btn" style="padding:6px 8px;font-size:11px">Копировать</button>
                <button id="debug-clear" class="menu-btn" style="padding:6px 8px;font-size:11px">Очистить</button>
            </div>
        </div>
        <div id="debug-log" style="font-family:monospace;color:#cbd5e1;line-height:1.3;user-select:text;-webkit-user-select:text;">
        </div>
    </div>
    <!-- debug toggle button removed -->
    <script>
        // dynamic debug panel is created by createDebugPanel() to avoid duplicate IDs
        // Copy button for environments without native DevTools (uses clipboard API with fallback)
        (function(){
            const copyBtn = document.getElementById('debug-copy');
            if (!copyBtn) return;
            copyBtn.addEventListener('click', async ()=>{
                const log = document.getElementById('debug-log');
                if (!log) return;
                const text = Array.from(log.children).map(n=>n.textContent).join('\n');
                if (navigator.clipboard && navigator.clipboard.writeText){
                    try{ await navigator.clipboard.writeText(text); copyBtn.textContent='Скопировано'; setTimeout(()=>copyBtn.textContent='Копировать',1500); return; }catch(e){}
                }
                // fallback
                try{
                    const ta = document.createElement('textarea'); ta.value = text; ta.style.position='fixed'; ta.style.left='-9999px'; ta.style.top='0'; document.body.appendChild(ta); ta.focus(); ta.select(); const ok = document.execCommand('copy'); document.body.removeChild(ta);
                    if (ok){ copyBtn.textContent='Скопировано'; setTimeout(()=>copyBtn.textContent='Копировать',1500); } else { throw new Error('copy failed'); }
                }catch(e){ copyBtn.textContent='Ошибка'; setTimeout(()=>copyBtn.textContent='Копировать',1500); }
            });
        })();
    </script>
    <!-- background music feature removed -->
    <script>
        // TGS (Telegram animated sticker) runtime loader: fetches /assets/trophy.tgs, inflates with pako and renders via lottie-web
        (function(){
            const CONTAINER_ID = 'tgs-trophy';
            const TGS_URL = '/assets/trophy.tgs'; // place your .tgs file here in repo: assets/trophy.tgs

            // dynamic script loader
            function loadScript(src){ return new Promise((res, rej)=>{ const s=document.createElement('script'); s.src=src; s.async=true; s.onload = ()=>res(); s.onerror = (e)=>rej(e); document.head.appendChild(s); }); }

            async function ensureDeps(){
                // pako for inflate, lottie for rendering
                if (!window.pako){ await loadScript('https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js'); }
                if (!window.lottie){ await loadScript('https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.9.6/lottie.min.js'); }
            }

            async function fetchAndRender(){
                const container = document.getElementById(CONTAINER_ID);
                if (!container) return;
                appendDebugLine && appendDebugLine('tgs-loader: start');
                try{
                    await ensureDeps();
                    appendDebugLine && appendDebugLine('tgs-loader: deps loaded (pako:' + !!window.pako + ', lottie:' + !!window.lottie + ')');
                }catch(e){ console.warn('tgs-loader: failed to load deps', e); appendDebugLine && appendDebugLine('tgs-loader: deps load error: '+(e&&e.message)); document.getElementById('svg-trophy').style.display='block'; return; }

                try{
                    appendDebugLine && appendDebugLine('tgs-loader: fetching ' + TGS_URL);
                    const resp = await fetch(TGS_URL);
                    appendDebugLine && appendDebugLine('tgs-loader: fetch response ' + resp.status);
                    if (!resp.ok) throw new Error('tgs fetch failed: ' + resp.status);
                    const arrayBuf = await resp.arrayBuffer();
                    appendDebugLine && appendDebugLine('tgs-loader: fetched ' + (arrayBuf.byteLength || 0) + ' bytes');
                    const bytes = new Uint8Array(arrayBuf);
                    // .tgs is zlib-compressed Lottie JSON (binary). Inflate with pako
                    let inflated = null;
                    try{
                        inflated = window.pako.inflate(bytes, { to: 'string' });
                        appendDebugLine && appendDebugLine('tgs-loader: inflate ok (zlib)');
                    }catch(e){
                        appendDebugLine && appendDebugLine('tgs-loader: inflate zlib failed, trying raw inflate: '+(e&&e.message));
                        try{
                            inflated = window.pako.inflateRaw(bytes, { to: 'string' });
                            appendDebugLine && appendDebugLine('tgs-loader: inflateRaw ok');
                        }catch(er){
                            appendDebugLine && appendDebugLine('tgs-loader: inflateRaw failed: '+(er&&er.message));
                            console.warn('tgs inflate failed', er);
                            throw er;
                        }
                    }
                    const json = JSON.parse(inflated);
                    appendDebugLine && appendDebugLine('tgs-loader: parsed JSON, layers=' + (json.layers ? json.layers.length : 'unknown'));
                    // render with lottie
                    container.innerHTML = ''; // clear
                    // create animation but do NOT autoplay; we'll control playback when modal is shown
                    const anim = window.lottie.loadAnimation({
                        container: container,
                        renderer: 'svg',
                        loop: false,
                        autoplay: false,
                        animationData: json
                    });
                    // store global reference so showEndScreen can trigger play()
                    try{ window.__tgs_trophy_anim = anim; }catch(e){}
                    // attach some debug listeners
                    try{
                        anim.addEventListener('DOMLoaded', ()=>{ appendDebugLine && appendDebugLine('tgs-loader: DOMLoaded'); });
                        anim.addEventListener('data_ready', ()=>{ appendDebugLine && appendDebugLine('tgs-loader: data_ready'); });
                        anim.addEventListener('complete', ()=>{ appendDebugLine && appendDebugLine('tgs-loader: complete'); });
                    }catch(e){ appendDebugLine && appendDebugLine('tgs-loader: addEventListener failed: '+(e&&e.message)); }
                    // small scaling to fit 48x48 box if needed
                    container.style.width = '48px'; container.style.height = '48px';
                    appendDebugLine && appendDebugLine('tgs-loader: animation loaded (autoplay=false)');
                }catch(e){
                    console.warn('tgs-loader error', e);
                    appendDebugLine && appendDebugLine('tgs-loader: error: '+(e&&e.message));
                    document.getElementById('svg-trophy').style.display='block';
                }
            }

            // Delay load until DOM ready
            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fetchAndRender); else fetchAndRender();
        })();
    </script>
</body>
</html>